# Реализация переноса времени на клиенте

## Обзор

Реализована логика переноса остатка времени между раундами игры исключительно на стороне клиента, без зависимости от сервера. Это обеспечивает полную автономность игры и минимизирует зависимость от интернета.

## Архитектура

### Хранение данных
- **localStorage**: Используется для сохранения перенесенного времени между раундами
- **Ключ**: `hatGame_carriedTime`
- **Формат**: Строковое представление числа секунд

### Функции

#### `saveCarriedTime(timeLeft)`
- Сохраняет перенесенное время в localStorage
- Если `timeLeft > 0` - сохраняет значение
- Если `timeLeft <= 0` - удаляет ключ из localStorage
- **Параметры**: `timeLeft` (number) - количество секунд для переноса
- **Возвращает**: void

#### `loadCarriedTime()`
- Загружает перенесенное время из localStorage
- Возвращает 0, если время не сохранено
- **Параметры**: нет
- **Возвращает**: number - количество секунд

#### `clearCarriedTime()`
- Удаляет перенесенное время из localStorage
- Используется при начале новой игры или после использования времени
- **Параметры**: нет
- **Возвращает**: void

## Интеграция с игровой логикой

### Завершение раунда
```javascript
// При завершении раунда
const carriedTime = Math.ceil(timerState.remainingTime / 1000);
saveCarriedTime(carriedTime);
```

### Начало нового раунда
```javascript
// При запуске таймера
const loadedCarriedTime = loadCarriedTime();
const actualDuration = loadedCarriedTime > 0 ? loadedCarriedTime : durationSeconds;

if (loadedCarriedTime > 0) {
    clearCarriedTime(); // Очищаем после использования
}
```

### Начало новой игры
```javascript
// При старте новой игры
clearCarriedTime(); // Очищаем все перенесенное время
```

## Логика работы

1. **Завершение раунда по истечению времени**: 
   - Перенесенное время = 0 (время истекло)
   - Время сохраняется в localStorage
   - Отправляется событие на сервер (для совместимости)

2. **Завершение раунда по исчерпанию слов**:
   - Вычисляется остаток времени на основе `timerState.remainingTime`
   - Время сохраняется в localStorage
   - Отправляется событие на сервер (для совместимости)

3. **Начало нового раунда**:
   - Загружается перенесенное время из localStorage
   - Если есть перенесенное время - используется только оно
   - Если нет - используется стандартное время раунда
   - Перенесенное время очищается после использования

4. **Начало новой игры**:
   - Все перенесенное время очищается

## Преимущества

- ✅ **Автономность**: Игра работает без интернета
- ✅ **Простота**: Нет серверной инфраструктуры для времени
- ✅ **Надежность**: Нет зависимости от сетевого соединения
- ✅ **Быстродействие**: Мгновенные переходы между раундами
- ✅ **Совместимость**: Сохранена совместимость с серверной логикой

## Тестирование

Создан тестовый файл `test_time_carry.html` для проверки:
- Сохранения времени
- Загрузки времени
- Полного цикла переноса
- Информации о localStorage

## Совместимость

Реализация сохраняет совместимость с существующей серверной логикой:
- События `round_completed_carried_time` и `carried_time_used` продолжают отправляться
- Серверная логика переноса времени остается рабочей
- Клиентская логика работает независимо от сервера

## Безопасность

Для настольной игры на одном устройстве:
- Игроки не используют читы
- Безопасность не критична
- localStorage защищен от случайного изменения
- Логика проста и понятна

## Исправления

### Проблема с вычислением времени
**Проблема**: Первоначальная реализация вычисляла перенесенное время на основе разности между временем запуска таймера и текущим клиентским временем, что включало паузы между раундами.

**Решение**: 
- Используется `timerState.remainingTime`, которое уже корректно вычислено с учетом пауз
- Добавлена функция `endRoundByWordsExhausted()` для правильного завершения раунда по исчерпанию слов
- Разделена логика для завершения раунда по истечению времени (перенесенное время = 0) и по исчерпанию слов (перенесенное время = остаток)

### Ключевые функции
- `calculateCarriedTime()` - использует `timerState.remainingTime` вместо текущего времени
- `endRoundByWordsExhausted()` - правильно завершает раунд при исчерпании слов
- Обновленная обработка события `round_completed` - проверяет состояние таймера

## Заключение

Реализованная логика полностью соответствует требованиям настольной игры:
- Работает на одном устройстве
- Не требует интернета
- Обеспечивает корректный перенос времени между раундами
- Учитывает только фактическое игровое время
- Проста в использовании и отладке
