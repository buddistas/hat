<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Шляпа - Игра в слова</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: white;
            overflow-x: hidden;
        }

        .container {
            max-width: 400px;
            margin: 0 auto;
            padding: 20px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5rem;
            font-weight: bold;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            opacity: 0.9;
            font-size: 1.1rem;
        }

        .screen {
            display: none;
            flex: 1;
            flex-direction: column;
        }

        .screen.active {
            display: flex;
        }

        .setup-form {
            background: rgba(255,255,255,0.1);
            border-radius: 20px;
            padding: 30px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
        }

        .form-group input, .form-group select {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 10px;
            background: rgba(255,255,255,0.9);
            color: #333;
            font-size: 16px;
        }

        .btn {
            background: #ff6b6b;
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
            margin-top: 10px;
        }

        .btn:hover {
            background: #ff5252;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255,107,107,0.4);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-secondary {
            background: rgba(255,255,255,0.2);
            border: 2px solid rgba(255,255,255,0.3);
        }

        .btn-secondary:hover {
            background: rgba(255,255,255,0.3);
        }

        .game-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            text-align: center;
            min-height: 0; /* Позволяет flex-элементам сжиматься */
        }

        .game-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            min-height: 0;
        }

        .current-word {
            font-size: 3rem;
            font-weight: bold;
            margin: 20px 0;
            padding: 0;
            background: transparent; /* делаем контейнер невидимым */
            border-radius: 0;
            backdrop-filter: none;
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            text-shadow: 0 2px 0 rgba(0,0,0,0.15), 0 4px 10px rgba(0,0,0,0.2);
            word-break: keep-all; /* Не разрываем слова по слогам */
            white-space: normal; /* Разрешаем перенос строк */
            overflow-wrap: break-word; /* Переносим только при необходимости */
            width: 100%;
            text-align: center;
            line-height: 1.2; /* Улучшаем читаемость при переносе строк */
        }

        .timer {
            font-size: 2rem;
            font-weight: bold;
            margin: 20px 0;
            color: #ffeb3b;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        /* Компактные кнопки управления в углах экрана */
        .compact-btn {
            position: fixed;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: none;
            font-size: 18px;
            cursor: pointer;
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .compact-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
        }

        .compact-btn:active {
            transform: scale(0.95);
        }

        .pause-btn {
            top: 15px;
            left: 15px;
            background: rgba(255,255,255,0.2);
            color: white;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.3);
        }

        .pause-btn:hover {
            background: rgba(255,255,255,0.3);
        }

        .end-btn {
            top: 15px;
            right: 15px;
            background: rgba(244,67,54,0.8);
            color: white;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(244,67,54,0.9);
        }

        .end-btn:hover {
            background: rgba(244,67,54,0.9);
        }

        .game-controls-top {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            justify-content: flex-end;
        }

        .game-controls {
            display: flex;
            gap: 15px;
            margin-top: 20px;
            width: 100%;
            max-width: 350px;
            flex-shrink: 0; /* Предотвращаем сжатие кнопок */
        }

        .game-controls .btn {
            flex: 1;
            margin: 0;
            padding: 20px;
            font-size: 16px;
        }

        .btn-small {
            padding: 8px 16px !important;
            font-size: 14px !important;
            margin: 0 !important;
            flex: none !important;
        }

        .btn-success {
            background: #4caf50;
        }

        .btn-success:hover {
            background: #45a049;
        }

        .btn-warning {
            background: #ff9800;
        }

        .btn-warning:hover {
            background: #f57c00;
        }

        .btn-danger {
            background: #f44336;
        }

        .btn-danger:hover {
            background: #da190b;
        }

        .scores {
            display: flex;
            justify-content: space-around;
            margin: 20px 0;
            flex-wrap: wrap;
            gap: 15px;
        }

        .score-item {
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 15px;
            text-align: center;
            min-width: 100px;
        }

        .score-item h3 {
            font-size: 1.2rem;
            margin-bottom: 5px;
        }

        .score-item .score {
            font-size: 2rem;
            font-weight: bold;
            color: #ffeb3b;
        }

        .round-info {
            text-align: center;
            margin-bottom: 20px;
            font-size: 1.2rem;
            opacity: 0.9;
        }

        .player-info {
            text-align: center;
            margin-bottom: 20px;
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .words-counter {
            text-align: center;
            margin-bottom: 20px;
            font-size: 1.1rem;
            font-weight: 600;
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            padding: 10px 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
            transition: all 0.3s ease;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }

        .words-counter:hover {
            background: rgba(255,255,255,0.15);
            transform: translateY(-1px);
        }

        .connection-status {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 15px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: bold;
        }

        .connection-status.connected {
            background: #4caf50;
            color: white;
        }

        .connection-status.disconnected {
            background: #f44336;
            color: white;
        }

        .results {
            background: rgba(255,255,255,0.1);
            border-radius: 20px;
            padding: 30px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
        }

        .results h2 {
            text-align: center;
            margin-bottom: 30px;
            font-size: 2rem;
        }

        .winner {
            text-align: center;
            margin: 20px 0;
            font-size: 1.5rem;
            color: #ffeb3b;
            font-weight: bold;
        }

        /* Стили для навигации между экранами статистики */
        .stats-navigation {
            display: flex;
            gap: 10px;
            margin: 20px 0;
            justify-content: center;
        }

        .stats-navigation .btn {
            padding: 10px 20px;
            font-size: 0.9em;
            min-width: 100px;
        }

        .stats-navigation .btn-active {
            background: #4CAF50;
            color: white;
        }

        /* Стили для таблиц статистики */
        .stats-table-container {
            margin: 20px auto;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            max-width: 700px;
            width: 100%;
            display: flex;
            justify-content: center;
        }

        .stats-table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            font-size: 0.9em;
            margin: 0 auto;
        }

        .stats-table th {
            background: #f5f5f5;
            padding: 12px 8px;
            text-align: center;
            font-weight: bold;
            border-bottom: 2px solid #ddd;
            color: #333;
        }

        .stats-table td {
            padding: 10px 8px;
            text-align: center;
            border-bottom: 1px solid #eee;
        }

        /* Черный цвет только для имен и названий команд */
        .stats-table td:first-child {
            color: #333;
        }


        .stats-table tbody tr:hover {
            background: #f9f9f9;
        }

        .stats-table tbody tr:last-child td {
            border-bottom: none;
        }

        /* Стили для очков */
        .score-positive {
            color: #4CAF50;
            font-weight: bold;
        }

        .score-negative {
            color: #f44336;
            font-weight: bold;
        }

        .score-zero {
            color: #666;
        }

        /* Адаптивность для мобильных устройств */
        @media (max-width: 768px) {
            .stats-table {
                font-size: 0.75em;
            }
            
            .stats-table th,
            .stats-table td {
                padding: 6px 3px;
            }
            
            .stats-navigation {
                flex-direction: column;
                align-items: center;
            }
            
            .stats-navigation .btn {
                width: 200px;
            }
            
            /* Делаем таблицы более компактными на мобильных */
            .stats-table th:nth-child(1),
            .stats-table td:nth-child(1) {
                min-width: 80px;
            }
            
            .stats-table th:nth-child(2),
            .stats-table td:nth-child(2) {
                min-width: 60px;
            }
        }
        
        @media (max-width: 480px) {
            .stats-table {
                font-size: 0.7em;
            }
            
            .stats-table th,
            .stats-table td {
                padding: 4px 2px;
            }
        }

        .team-item {
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 10px;
            border: 1px solid rgba(255,255,255,0.2);
        }

        .teams-container {
            max-height: 400px;
            overflow-y: auto;
            padding-right: 10px;
        }

        .teams-container::-webkit-scrollbar {
            width: 6px;
        }

        .teams-container::-webkit-scrollbar-track {
            background: rgba(255,255,255,0.1);
            border-radius: 3px;
        }

        .teams-container::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.3);
            border-radius: 3px;
        }

        .teams-container::-webkit-scrollbar-thumb:hover {
            background: rgba(255,255,255,0.5);
        }

        .team-item h3 {
            margin-bottom: 10px;
            color: #ffeb3b;
            font-size: 1.1rem;
        }

        .team-players {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .player-tag {
            background: rgba(255,255,255,0.2);
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 14px;
            border: 1px solid rgba(255,255,255,0.3);
        }

        .player-intro-info {
            background: rgba(255,255,255,0.1);
            border-radius: 20px;
            padding: 40px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
            text-align: center;
            max-width: 400px;
            margin: 0 auto;
            animation: playerIntroSlideIn 0.8s ease-out;
        }

        .handoff-info {
            background: rgba(255,255,255,0.1);
            border-radius: 20px;
            padding: 40px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
            text-align: center;
            max-width: 400px;
            margin: 0 auto;
        }

        .current-player-info {
            margin: 30px 0;
            animation: playerInfoFadeIn 1s ease-out 0.3s both;
        }

        .current-player-name {
            font-size: 2.5rem;
            font-weight: bold;
            color: #ffeb3b;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            margin-bottom: 10px;
            animation: playerNameGlow 2s ease-in-out infinite;
        }

        .current-player-team {
            font-size: 1.3rem;
            opacity: 0.9;
            color: white;
            animation: playerTeamSlideIn 0.8s ease-out 0.5s both;
        }

        .next-player-info {
            margin: 30px 0;
        }

        .next-player-name {
            font-size: 2.5rem;
            font-weight: bold;
            color: #ffeb3b;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            margin-bottom: 10px;
        }

        .next-player-team {
            font-size: 1.3rem;
            opacity: 0.9;
            color: white;
        }

        /* Стили для экранов правил */
        .rules-container {
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 20px;
        }

        .rules-content {
            background: rgba(255,255,255,0.1);
            border-radius: 25px;
            padding: 40px;
            backdrop-filter: blur(15px);
            border: 2px solid rgba(255,255,255,0.2);
            max-width: 500px;
            width: 100%;
            text-align: center;
            animation: rulesSlideIn 0.8s ease-out;
            box-shadow: 0 20px 40px rgba(0,0,0,0.2);
        }

        .rules-header {
            margin-bottom: 40px;
            animation: rulesHeaderFadeIn 1s ease-out 0.3s both;
        }

        .rules-title {
            font-size: 3rem;
            font-weight: bold;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            background: linear-gradient(45deg, #ffeb3b, #ff9800);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .rules-subtitle {
            font-size: 1.3rem;
            opacity: 0.9;
            color: #ffeb3b;
            font-weight: 600;
        }

        .rules-body {
            margin-bottom: 40px;
        }

        .rule-item {
            display: flex;
            align-items: flex-start;
            margin-bottom: 25px;
            padding: 20px;
            background: rgba(255,255,255,0.05);
            border-radius: 15px;
            border: 1px solid rgba(255,255,255,0.1);
            animation: ruleItemSlideIn 0.6s ease-out both;
            transition: all 0.3s ease;
        }

        .rule-item:nth-child(1) { animation-delay: 0.5s; }
        .rule-item:nth-child(2) { animation-delay: 0.7s; }
        .rule-item:nth-child(3) { animation-delay: 0.9s; }

        .rule-item:hover {
            background: rgba(255,255,255,0.1);
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(0,0,0,0.1);
        }

        .rule-icon {
            font-size: 2.5rem;
            margin-right: 20px;
            flex-shrink: 0;
            animation: ruleIconBounce 1s ease-out both;
        }

        .rule-item:nth-child(1) .rule-icon { animation-delay: 0.6s; }
        .rule-item:nth-child(2) .rule-icon { animation-delay: 0.8s; }
        .rule-item:nth-child(3) .rule-icon { animation-delay: 1s; }

        .rule-text {
            text-align: left;
            flex: 1;
        }

        .rule-text h3 {
            font-size: 1.2rem;
            margin-bottom: 8px;
            color: #ffeb3b;
            font-weight: 600;
        }

        .rule-text p {
            font-size: 1rem;
            line-height: 1.5;
            opacity: 0.9;
        }

        .rules-btn {
            background: linear-gradient(45deg, #4caf50, #45a049);
            font-size: 1.2rem;
            padding: 18px 40px;
            border-radius: 30px;
            animation: rulesBtnPulse 2s ease-in-out infinite;
            box-shadow: 0 10px 20px rgba(76,175,80,0.3);
            transition: all 0.3s ease;
        }

        .rules-btn:hover {
            background: linear-gradient(45deg, #45a049, #4caf50);
            transform: translateY(-3px);
            box-shadow: 0 15px 30px rgba(76,175,80,0.4);
        }

        .rules-btn:active {
            transform: translateY(-1px);
        }

        /* Анимации */
        @keyframes rulesSlideIn {
            from {
                opacity: 0;
                transform: translateY(50px) scale(0.9);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        @keyframes rulesHeaderFadeIn {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes ruleItemSlideIn {
            from {
                opacity: 0;
                transform: translateX(-30px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        @keyframes ruleIconBounce {
            0% {
                opacity: 0;
                transform: scale(0.3) rotate(-10deg);
            }
            50% {
                transform: scale(1.1) rotate(5deg);
            }
            100% {
                opacity: 1;
                transform: scale(1) rotate(0deg);
            }
        }

        @keyframes rulesBtnPulse {
            0%, 100% {
                box-shadow: 0 10px 20px rgba(76,175,80,0.3);
            }
            50% {
                box-shadow: 0 15px 30px rgba(76,175,80,0.5);
            }
        }

        /* Анимации для экрана представления игрока */
        @keyframes playerIntroSlideIn {
            from {
                opacity: 0;
                transform: translateY(50px) scale(0.9);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        @keyframes playerInfoFadeIn {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes playerNameGlow {
            0%, 100% {
                text-shadow: 2px 2px 4px rgba(0,0,0,0.5), 0 0 20px rgba(255,235,59,0.3);
            }
            50% {
                text-shadow: 2px 2px 4px rgba(0,0,0,0.5), 0 0 30px rgba(255,235,59,0.6);
            }
        }

        @keyframes playerTeamSlideIn {
            from {
                opacity: 0;
                transform: translateX(-30px);
            }
            to {
                opacity: 0.9;
                transform: translateX(0);
            }
        }

        @media (max-width: 480px) {
            .container {
                padding: 15px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .current-word {
                font-size: 2rem;
                padding: 15px;
                word-break: keep-all; /* Не разрываем слова по слогам на мобильных */
                line-height: 1.3; /* Немного больше межстрочный интервал на мобильных */
            }
            
            .game-controls {
                flex-direction: column;
                max-width: 100%;
            }

            /* Адаптация компактных кнопок для мобильных */
            .compact-btn {
                width: 35px;
                height: 35px;
                font-size: 16px;
            }

            .pause-btn {
                top: 10px;
                left: 10px;
            }

            .end-btn {
                top: 10px;
                right: 10px;
            }

            .game-controls-top {
                flex-direction: column;
                gap: 8px;
            }

            .teams-container {
                max-height: 300px;
            }

            .player-tag {
                font-size: 12px;
                padding: 4px 8px;
            }

            .team-item {
                padding: 12px;
            }

            .team-item h3 {
                font-size: 1rem;
            }

            /* Адаптация экранов правил для мобильных */
            .rules-content {
                padding: 25px;
                margin: 10px;
            }

            .rules-title {
                font-size: 2.2rem;
            }

            .rules-subtitle {
                font-size: 1.1rem;
            }

            .rule-item {
                flex-direction: column;
                text-align: center;
                padding: 15px;
            }

            .rule-icon {
                margin-right: 0;
                margin-bottom: 10px;
                font-size: 2rem;
            }

            .rule-text {
                text-align: center;
            }

            .rule-text h3 {
                font-size: 1.1rem;
            }

            .rule-text p {
                font-size: 0.9rem;
            }

            .rules-btn {
                font-size: 1.1rem;
                padding: 15px 30px;
            }

            /* Адаптация экрана представления игрока для мобильных */
            .player-intro-info {
                padding: 25px;
                margin: 10px;
            }

            .current-player-name {
                font-size: 2rem;
            }

            .current-player-team {
                font-size: 1.1rem;
            }
        }
    </style>
</head>
<body>
    <div class="connection-status" id="connectionStatus">Подключение...</div>
    
    <div class="container">
        <div class="header">
            <h1>🎩 Шляпа</h1>
            <p>Игра в слова для компании</p>
        </div>

        <!-- Экран разблокировки аудио -->
        <div class="screen active" id="audioUnlockScreen">
            <div class="setup-form">
                <h2 style="text-align: center; margin-bottom: 30px;">🎵 Включить звук</h2>
                <p style="text-align: center; margin-bottom: 30px; font-size: 1.1rem; opacity: 0.9;">
                    Для полного игрового опыта рекомендуется включить звук.<br>
                    Нажмите кнопку ниже, чтобы разблокировать аудио.
                </p>
                <button class="btn" onclick="buttonClick(enableAudio)">🔊 Включить звук</button>
                <button class="btn btn-secondary" onclick="buttonClick(skipAudio)" style="margin-top: 15px;">🔇 Продолжить без звука</button>
            </div>
        </div>

        <!-- Экран настройки игры -->
        <div class="screen" id="setupScreen">
            <div class="setup-form">
                <h2 style="text-align: center; margin-bottom: 30px;">Настройка игры</h2>
                
                <div class="form-group">
                    <label for="playerCount">Количество игроков:</label>
                    <select id="playerCount">
                        <option value="4">4 игрока</option>
                        <option value="5">5 игроков</option>
                        <option value="6">6 игроков</option>
                        <option value="7">7 игроков</option>
                        <option value="8">8 игроков</option>
                        <option value="9">9 игроков</option>
                        <option value="10">10 игроков</option>
                        <option value="11">11 игроков</option>
                        <option value="12">12 игроков</option>
                        <option value="13">13 игроков</option>
                        <option value="14">14 игроков</option>
                        <option value="15">15 игроков</option>
                        <option value="16">16 игроков</option>
                        <option value="17">17 игроков</option>
                        <option value="18">18 игроков</option>
                        <option value="19">19 игроков</option>
                        <option value="20">20 игроков</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="teamCount">Количество команд:</label>
                    <select id="teamCount">
                        <option value="2">2 команды</option>
                        <option value="3">3 команды</option>
                        <option value="4">4 команды</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="roundDuration">Длительность хода (секунды):</label>
                    <select id="roundDuration">
                        <option value="30" selected>30 секунд</option>
                        <option value="60">60 секунд</option>
                        <option value="90">90 секунд</option>
                    </select>
                </div>

                <button class="btn" onclick="buttonClick(setupTeams)">Настроить команды</button>
            </div>
        </div>

        <!-- Экран настройки команд -->
        <div class="screen" id="teamsScreen">
            <div class="setup-form">
                <h2 style="text-align: center; margin-bottom: 30px;">Настройка команд</h2>
                
                <div class="form-group">
                    <label>Распределение игроков по командам:</label>
                    <div class="teams-container">
                        <div id="teamsList" style="margin-top: 15px;"></div>
                    </div>
                    <button class="btn btn-secondary" onclick="buttonClick(shuffleTeams)" style="margin-top: 15px;">Перемешать команды</button>
                </div>

                <button class="btn" onclick="buttonClick(setupWords)">Настроить слова</button>
            </div>
        </div>

        <!-- Экран настройки слов -->
        <div class="screen" id="wordsScreen">
            <div class="setup-form">
                <h2 style="text-align: center; margin-bottom: 30px;">Настройка слов</h2>
                
                <div class="form-group">
                    <label for="wordsCount">Количество слов в шляпе:</label>
                    <select id="wordsCount">
                        <option value="20">20 слов</option>
                        <option value="30">30 слов</option>
                        <option value="40">40 слов</option>
                        <option value="50">50 слов</option>
                        <option value="60">60 слов</option>
                        <option value="70">70 слов</option>
                        <option value="80">80 слов</option>
                        <option value="90">90 слов</option>
                        <option value="100" selected>100 слов</option>
                        <option value="120">120 слов</option>
                        <option value="140">140 слов</option>
                        <option value="160">160 слов</option>
                        <option value="180">180 слов</option>
                        <option value="200">200 слов</option>
                    </select>
                </div>

                <div class="form-group">
                    <label style="display:block; margin-bottom: 8px;">Категории:</label>
                    <div id="categoriesContainer" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); gap: 10px; padding: 6px; border: 1px solid rgba(255,255,255,0.15); border-radius: 12px;"></div>
                    <div style="margin-top: 12px; display: flex; gap: 10px; flex-wrap: wrap; align-items:center;">
                        <button type="button" class="btn" style="padding: 6px 10px;" onclick="selectAllCategories(true)">Выбрать все</button>
                        <button type="button" class="btn" style="padding: 6px 10px;" onclick="selectAllCategories(false)">Сбросить</button>
                    </div>
                </div>

                <div class="form-group">
                    <label style="display:block; margin-bottom: 8px;">Сложность:</label>
                    <div style="display:flex; align-items:center; justify-content:center; gap:12px; width:100%;">
                        <span style="opacity:0.85; font-size:14px;">Нормальная</span>
                        <label style="position:relative; display:inline-block; width:60px; height:34px;">
                            <input type="checkbox" id="difficultyToggle" name="difficulty" aria-label="Переключить сложность: нормальная/повышенная" title="Переключить сложность" checked style="position:absolute; top:0; left:0; width:100%; height:100%; margin:0; opacity:0;">
                            <span style="position:absolute; cursor:pointer; top:0; left:0; right:0; bottom:0; background-color:#666; transition:.2s; border-radius:34px;"></span>
                            <span style="position:absolute; content:''; height:26px; width:26px; left:4px; bottom:4px; background-color:#fff; transition:.2s; border-radius:50%;" id="difficultyKnob"></span>
                        </label>
                        <span style="opacity:0.85; font-size:14px;">Повышенная</span>
                    </div>
                    <!-- Слайдер процента сложных слов -->
                    <div style="margin-top: 14px;">
                        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:6px;">
                            <label for="difficultySlider" style="opacity:0.9;">Процент сложных слов</label>
                            <span id="difficultySliderValue" style="opacity:0.9; font-variant-numeric: tabular-nums;">25%</span>
                        </div>
                        <input type="range" id="difficultySlider" min="0" max="100" step="5" value="25" style="width:100%;" disabled>
                    </div>
                </div>

                <div class="form-group">
                    <p style="text-align: center; opacity: 0.8; font-size: 14px; margin-top: 10px;">
                        Слова будут выбраны случайным образом из выбранных категорий и уровней
                    </p>
                </div>

                <button class="btn" onclick="buttonClick(startGame)">Начать игру</button>
            </div>
        </div>

        <!-- Экран игры -->
        <div class="screen" id="gameScreen">
            <!-- Компактные кнопки управления в углах экрана -->
            <button class="compact-btn pause-btn" onclick="pauseGame()" id="pauseBtn">⏸️</button>
            <button class="compact-btn end-btn" onclick="endGame()">✕</button>
            
            <div class="round-info" id="roundInfo" style="font-weight: bold; font-size: 1.2em; color: #ffffff;">Текущий раунд: 1 из 3</div>
            <div class="player-info" id="playerInfo">Ход игрока</div>
            <div class="words-counter" id="wordsCounter">Еще слов - 99</div>
            
            <div class="game-area">
                <div class="game-content">
                    <div class="timer" id="timer">30</div>
                    <div class="current-word" id="currentWord">Нажмите "Пропуск" для следующего слова</div>
                </div>
                
                <div class="game-controls">
                    <button class="btn btn-success" onclick="wordGuessed()">Верно</button>
                    <button class="btn btn-warning" onclick="wordPassed()">Пропуск</button>
                </div>
            </div>
        </div>

        <!-- Экран представления игрока -->
        <div class="screen" id="playerIntroScreen">
            <div class="game-area">
                <div class="player-intro-info">
                    <h2 style="text-align: center; margin-bottom: 30px; color: #ffeb3b;">Ход игрока</h2>
                    <div class="current-player-info">
                        <div class="current-player-name" id="currentPlayerName">Игрок</div>
                        <div class="current-player-team" id="currentPlayerTeam">Команда</div>
                    </div>
                    <div class="player-intro-message">
                        <p style="text-align: center; font-size: 1.2rem; margin: 30px 0; opacity: 0.9;">
                            Готовы начать ход?
                        </p>
                    </div>
                    <button class="btn" onclick="buttonClick(startPlayerTurn)" id="startPlayerTurnBtn">Начать</button>
                </div>
            </div>
        </div>

        <!-- Экран передачи хода -->
        <div class="screen" id="handoffScreen">
            <div class="game-area">
                <div class="handoff-info">
                    <h2 style="text-align: center; margin-bottom: 30px; color: #ffeb3b;">Передача хода</h2>
                    <div class="next-player-info">
                        <div class="next-player-name" id="nextPlayerName">Игрок</div>
                        <div class="next-player-team" id="nextPlayerTeam">Команда</div>
                    </div>
                    <div class="handoff-message">
                        <p style="text-align: center; font-size: 1.2rem; margin: 30px 0; opacity: 0.9;">
                            Готовы начать ход?
                        </p>
                    </div>
                    <button class="btn" onclick="buttonClick(startNextTurn)" id="startTurnBtn">Старт</button>
                </div>
            </div>
        </div>

        <!-- Экран счета между раундами -->
        <div class="screen" id="roundScoresScreen">
            <div class="results">
                <h2>Результаты раунда</h2>
                <div class="scores" id="roundScores"></div>
                
                <button class="btn" onclick="buttonClick(continueToNextRound)" id="continueBtn">Продолжить</button>
            </div>
        </div>

        <!-- Экран правил 1-го раунда -->
        <div class="screen" id="rulesScreen1">
            <div class="rules-container">
                <div class="rules-content">
                    <div class="rules-header">
                        <h1 class="rules-title">🎯 Раунд 1</h1>
                        <div class="rules-subtitle">Свободное объяснение</div>
                    </div>
                    
                    <div class="rules-body">
                        <div class="rule-item">
                            <div class="rule-icon">💬</div>
                            <div class="rule-text">
                                <h3>Объясняйте слова словами</h3>
                                <p>Используйте любые слова для объяснения, но не называйте само слово или однокоренные слова</p>
                            </div>
                        </div>
                        
                        <div class="rule-item">
                            <div class="rule-icon">🚫</div>
                            <div class="rule-text">
                                <h3>Запрещено</h3>
                                <p>Жесты, мимика, звуки, созвучия и однокоренные слова</p>
                            </div>
                        </div>
                        
                        
                    </div>
                    
                    <button class="btn rules-btn" onclick="buttonClick(startFirstRound)">Ясно</button>
                </div>
            </div>
        </div>

        <!-- Экран правил 2-го раунда -->
        <div class="screen" id="rulesScreen2">
            <div class="rules-container">
                <div class="rules-content">
                    <div class="rules-header">
                        <h1 class="rules-title">🎭 Раунд 2</h1>
                        <div class="rules-subtitle">Жесты и мимика</div>
                    </div>
                    
                    <div class="rules-body">
                        <div class="rule-item">
                            <div class="rule-icon">🤲</div>
                            <div class="rule-text">
                                <h3>Только жесты и мимика</h3>
                                <p>Объясняйте слова жестами, мимикой и движениями тела</p>
                            </div>
                        </div>
                        
                        <div class="rule-item">
                            <div class="rule-icon">🚫</div>
                            <div class="rule-text">
                                <h3>Слова запрещены!</h3>
                                <p>Никаких слов, звуков или текстовых подсказок</p>
                            </div>
                        </div>
                        
                        
                    </div>
                    
                    <button class="btn rules-btn" onclick="buttonClick(startSecondRound)">Ясно</button>
                </div>
            </div>
        </div>

        <!-- Экран правил 3-го раунда -->
        <div class="screen" id="rulesScreen3">
            <div class="rules-container">
                <div class="rules-content">
                    <div class="rules-header">
                        <h1 class="rules-title">🎯 Раунд 3</h1>
                        <div class="rules-subtitle">Одно слово</div>
                    </div>
                    
                    <div class="rules-body">
                        <div class="rule-item">
                            <div class="rule-icon">📝</div>
                            <div class="rule-text">
                                <h3>Только одно слово</h3>
                                <p>Объясняйте каждое слово только одним словом-ассоциацией</p>
                            </div>
                        </div>
                        
                        <div class="rule-item">
                            <div class="rule-icon">🎯</div>
                            <div class="rule-text">
                                <h3>Максимально точно</h3>
                                <p>Выбирайте самое точное и понятное слово для объяснения</p>
                            </div>
                        </div>
                        
                        
                    </div>
                    
                    <button class="btn rules-btn" onclick="buttonClick(startThirdRound)">Ясно</button>
                </div>
            </div>
        </div>

        <!-- Экран результатов команд -->
        <div class="screen" id="teamResultsScreen">
            <div class="results">
                <h2>Результаты команд</h2>
                <div class="winner" id="winner"></div>
                
                <!-- Навигация между экранами статистики -->
                <div class="stats-navigation">
                    <button class="btn btn-active" onclick="buttonClick(showTeamStats)">Команды</button>
                    <button class="btn" onclick="buttonClick(showPlayerStats)">Игроки</button>
                </div>
                
                <!-- Таблица результатов команд -->
                <div class="stats-table-container">
                    <table class="stats-table" id="teamStatsTable">
                        <thead>
                            <tr>
                                <th>Команда</th>
                                <th>Раунд 1</th>
                                <th>Раунд 2</th>
                                <th>Раунд 3</th>
                                <th>Итого</th>
                            </tr>
                        </thead>
                        <tbody id="teamStatsBody">
                        </tbody>
                    </table>
                </div>
                
                <button class="btn" onclick="buttonClick(newGame)">Новая игра</button>
            </div>
        </div>

        <!-- Экран результатов игроков -->
        <div class="screen" id="playerResultsScreen">
            <div class="results">
                <h2>Личные результаты</h2>
                
                <!-- Навигация между экранами статистики -->
                <div class="stats-navigation">
                    <button class="btn" onclick="buttonClick(showTeamStats)">Команды</button>
                    <button class="btn btn-active" onclick="buttonClick(showPlayerStats)">Игроки</button>
                </div>
                
                <!-- Таблица результатов игроков -->
                <div class="stats-table-container">
                    <table class="stats-table" id="playerStatsTable">
                        <thead>
                            <tr>
                                <th>Игрок</th>
                                <th>Очки</th>
                            </tr>
                        </thead>
                        <tbody id="playerStatsBody">
                        </tbody>
                    </table>
                </div>
                
                <button class="btn" onclick="buttonClick(newGame)">Новая игра</button>
            </div>
        </div>
    </div>

    <script>
        let ws;
        let gameState = {};
        let gameSetup = {
            players: [],
            teams: [],
            roundDuration: 30,
            wordsCount: 100
        };

        // Звуковая система
        let audioContext;
        let soundEnabled = false;
        let audioUnlocked = false;
        
        // Аудиофайлы
        let audioFiles = {
            warning5s: null,
            next: null,
            done: null,
            click: null,
            start: null,
            finish: null
        };

        // Инициализация звуковой системы
        function initAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                console.log('Аудио контекст инициализирован');
            } catch (error) {
                console.error('Ошибка инициализации аудио:', error);
            }
        }

        // Загрузка аудиофайлов
        function loadAudioFiles() {
            console.log('Загрузка аудиофайлов...');
            
            // Создаем объекты Audio для каждого звука (из папки /Sound)
            audioFiles.done = new Audio('/Sound/done.mp3');
            audioFiles.next = new Audio('/Sound/next.mp3');
            audioFiles.click = new Audio('/Sound/click.mp3');
            audioFiles.start = new Audio('/Sound/start.mp3');
            audioFiles.finish = new Audio('/Sound/finish.mp3');
            audioFiles.warning5s = new Audio('/Sound/5timer2.mp3');

            // Используются только текущие файлы звуков
            
            // Прелоад и громкость
            Object.values(audioFiles).forEach(audio => {
                if (audio && typeof audio.preload !== 'undefined') {
                    audio.preload = 'auto';
                    audio.volume = 0.6;
                }
            });
            
            console.log('Аудиофайлы загружены');
        }

        // Воспроизведение аудиофайла
        function playAudioFile(audioFile, volume = 0.5) {
            if (!soundEnabled || !audioUnlocked || !audioFile) return;
            
            try {
                audioFile.volume = volume;
                audioFile.currentTime = 0; // Сбрасываем на начало
                audioFile.play().catch(error => {
                    console.error('Ошибка воспроизведения звука:', error);
                });
            } catch (error) {
                console.error('Ошибка воспроизведения аудиофайла:', error);
            }
        }

        // Разблокировка аудио (требуется для первого воспроизведения)
        function unlockAudio() {
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume().then(() => {
                    console.log('Аудио разблокировано');
                    audioUnlocked = true;
                });
            }
        }

        // Создание тонального звука
        function createTone(frequency, duration, type = 'sine', volume = 0.3) {
            if (!audioContext || !audioUnlocked) return;

            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
            oscillator.type = type;

            // Настройка громкости с плавным затуханием
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(volume, audioContext.currentTime + 0.01);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);

            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration);
        }

        // Создание шуршащего звука (белый шум с фильтрацией)
        function createRustleSound(duration = 0.4, volume = 0.3) {
            if (!audioContext || !audioUnlocked) return;

            // Создаем источник белого шума
            const bufferSize = audioContext.sampleRate * duration;
            const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const output = buffer.getChannelData(0);

            // Генерируем белый шум
            for (let i = 0; i < bufferSize; i++) {
                output[i] = Math.random() * 2 - 1;
            }

            const whiteNoise = audioContext.createBufferSource();
            whiteNoise.buffer = buffer;

            // Создаем фильтр для имитации шуршания
            const filter = audioContext.createBiquadFilter();
            filter.type = 'bandpass';
            filter.frequency.setValueAtTime(800, audioContext.currentTime);
            filter.Q.setValueAtTime(1, audioContext.currentTime);

            // Создаем модуляцию частоты для более реалистичного звука
            const lfo = audioContext.createOscillator();
            const lfoGain = audioContext.createGain();
            lfo.frequency.setValueAtTime(15, audioContext.currentTime);
            lfoGain.gain.setValueAtTime(200, audioContext.currentTime);
            lfo.connect(lfoGain);
            lfoGain.connect(filter.frequency);

            // Создаем узел громкости с затуханием
            const gainNode = audioContext.createGain();
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(volume, audioContext.currentTime + 0.01);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);

            // Подключаем цепочку: белый шум -> фильтр -> громкость -> выход
            whiteNoise.connect(filter);
            filter.connect(gainNode);
            gainNode.connect(audioContext.destination);

            // Запускаем звук
            whiteNoise.start(audioContext.currentTime);
            lfo.start(audioContext.currentTime);
            whiteNoise.stop(audioContext.currentTime + duration);
            lfo.stop(audioContext.currentTime + duration);
        }

        // Создание реалистичного звука подключения устройства Windows (для кнопки "Верно")
        function createDeviceConnectSound(duration = 0.6, volume = 0.5) {
            if (!audioContext || !audioUnlocked) return;

            // Основной тон - восходящая мелодия (характерная для Windows)
            const mainOscillator = audioContext.createOscillator();
            const mainGain = audioContext.createGain();
            
            // Создаем мелодию подключения: до-ми-соль (мажорное трезвучие)
            const frequencies = [261.63, 329.63, 392.00]; // C4, E4, G4
            const noteDuration = duration / 3;
            
            mainOscillator.frequency.setValueAtTime(frequencies[0], audioContext.currentTime);
            mainOscillator.frequency.setValueAtTime(frequencies[1], audioContext.currentTime + noteDuration);
            mainOscillator.frequency.setValueAtTime(frequencies[2], audioContext.currentTime + noteDuration * 2);
            mainOscillator.type = 'sine';

            // Создаем гармоники для более богатого звучания
            const harmonic1 = audioContext.createOscillator();
            const harmonic2 = audioContext.createOscillator();
            const harmonicGain = audioContext.createGain();
            
            harmonic1.frequency.setValueAtTime(frequencies[0] * 2, audioContext.currentTime);
            harmonic1.frequency.setValueAtTime(frequencies[1] * 2, audioContext.currentTime + noteDuration);
            harmonic1.frequency.setValueAtTime(frequencies[2] * 2, audioContext.currentTime + noteDuration * 2);
            harmonic1.type = 'sine';
            
            harmonic2.frequency.setValueAtTime(frequencies[0] * 3, audioContext.currentTime);
            harmonic2.frequency.setValueAtTime(frequencies[1] * 3, audioContext.currentTime + noteDuration);
            harmonic2.frequency.setValueAtTime(frequencies[2] * 3, audioContext.currentTime + noteDuration * 2);
            harmonic2.type = 'sine';

            // Создаем фильтр для придания "цифрового" звучания Windows
            const filter = audioContext.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(2000, audioContext.currentTime);
            filter.Q.setValueAtTime(1, audioContext.currentTime);

            // Настройка громкости с характерным для Windows ADSR
            mainGain.gain.setValueAtTime(0, audioContext.currentTime);
            mainGain.gain.linearRampToValueAtTime(volume, audioContext.currentTime + 0.02); // Attack
            mainGain.gain.setValueAtTime(volume * 0.8, audioContext.currentTime + duration * 0.8); // Sustain
            mainGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration); // Release
            
            harmonicGain.gain.setValueAtTime(0, audioContext.currentTime);
            harmonicGain.gain.linearRampToValueAtTime(volume * 0.3, audioContext.currentTime + 0.02);
            harmonicGain.gain.setValueAtTime(volume * 0.2, audioContext.currentTime + duration * 0.8);
            harmonicGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);

            // Подключаем цепочку
            mainOscillator.connect(filter);
            harmonic1.connect(harmonicGain);
            harmonic2.connect(harmonicGain);
            filter.connect(mainGain);
            mainGain.connect(audioContext.destination);
            harmonicGain.connect(audioContext.destination);

            // Запускаем звуки
            mainOscillator.start(audioContext.currentTime);
            harmonic1.start(audioContext.currentTime);
            harmonic2.start(audioContext.currentTime);
            mainOscillator.stop(audioContext.currentTime + duration);
            harmonic1.stop(audioContext.currentTime + duration);
            harmonic2.stop(audioContext.currentTime + duration);
        }

        // Создание реалистичного звука отключения устройства Windows (для кнопки "Пропуск")
        function createDeviceDisconnectSound(duration = 0.4, volume = 0.5) {
            if (!audioContext || !audioUnlocked) return;

            // Основной тон - нисходящая мелодия (характерная для Windows отключения)
            const mainOscillator = audioContext.createOscillator();
            const mainGain = audioContext.createGain();
            
            // Создаем мелодию отключения: соль-ми-до (нисходящее трезвучие)
            const frequencies = [392.00, 329.63, 261.63]; // G4, E4, C4
            const noteDuration = duration / 3;
            
            mainOscillator.frequency.setValueAtTime(frequencies[0], audioContext.currentTime);
            mainOscillator.frequency.setValueAtTime(frequencies[1], audioContext.currentTime + noteDuration);
            mainOscillator.frequency.setValueAtTime(frequencies[2], audioContext.currentTime + noteDuration * 2);
            mainOscillator.type = 'sine';

            // Создаем диссонансный тон для "отключения"
            const dissonanceOscillator = audioContext.createOscillator();
            const dissonanceGain = audioContext.createGain();
            
            // Диссонансная частота (малая секунда)
            dissonanceOscillator.frequency.setValueAtTime(415.30, audioContext.currentTime); // G#4
            dissonanceOscillator.frequency.setValueAtTime(349.23, audioContext.currentTime + noteDuration); // F4
            dissonanceOscillator.frequency.setValueAtTime(277.18, audioContext.currentTime + noteDuration * 2); // C#4
            dissonanceOscillator.type = 'sawtooth';

            // Создаем фильтр с более резким звучанием
            const filter = audioContext.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(1500, audioContext.currentTime);
            filter.frequency.exponentialRampToValueAtTime(800, audioContext.currentTime + duration);
            filter.Q.setValueAtTime(2, audioContext.currentTime);

            // Создаем дополнительный "щелчок" отключения
            const clickOscillator = audioContext.createOscillator();
            const clickGain = audioContext.createGain();
            clickOscillator.frequency.setValueAtTime(2000, audioContext.currentTime);
            clickOscillator.frequency.exponentialRampToValueAtTime(200, audioContext.currentTime + duration * 0.3);
            clickOscillator.type = 'square';

            // Настройка громкости с резким затуханием (характерно для отключения)
            mainGain.gain.setValueAtTime(0, audioContext.currentTime);
            mainGain.gain.linearRampToValueAtTime(volume, audioContext.currentTime + 0.01);
            mainGain.gain.setValueAtTime(volume * 0.6, audioContext.currentTime + duration * 0.5);
            mainGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
            
            dissonanceGain.gain.setValueAtTime(0, audioContext.currentTime);
            dissonanceGain.gain.linearRampToValueAtTime(volume * 0.4, audioContext.currentTime + 0.01);
            dissonanceGain.gain.setValueAtTime(volume * 0.2, audioContext.currentTime + duration * 0.5);
            dissonanceGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
            
            clickGain.gain.setValueAtTime(0, audioContext.currentTime);
            clickGain.gain.linearRampToValueAtTime(volume * 0.3, audioContext.currentTime + 0.005);
            clickGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration * 0.3);

            // Подключаем цепочки
            mainOscillator.connect(filter);
            dissonanceOscillator.connect(dissonanceGain);
            clickOscillator.connect(clickGain);
            filter.connect(mainGain);
            mainGain.connect(audioContext.destination);
            dissonanceGain.connect(audioContext.destination);
            clickGain.connect(audioContext.destination);

            // Запускаем звуки
            mainOscillator.start(audioContext.currentTime);
            dissonanceOscillator.start(audioContext.currentTime);
            clickOscillator.start(audioContext.currentTime);
            mainOscillator.stop(audioContext.currentTime + duration);
            dissonanceOscillator.stop(audioContext.currentTime + duration);
            clickOscillator.stop(audioContext.currentTime + duration * 0.3);
        }

        // Альтернативный звук отключения устройства (более резкий)
        function createUSBDisconnectSound(duration = 0.2, volume = 0.4) {
            if (!audioContext || !audioUnlocked) return;

            // Создаем осциллятор с быстрым изменением частоты
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            // Резкое падение частоты (имитация "отключения")
            oscillator.frequency.setValueAtTime(1000, audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(100, audioContext.currentTime + duration * 0.3);
            oscillator.frequency.setValueAtTime(100, audioContext.currentTime + duration * 0.3);
            oscillator.type = 'sawtooth';

            // Создаем фильтр для "цифрового" звучания
            const filter = audioContext.createBiquadFilter();
            filter.type = 'bandpass';
            filter.frequency.setValueAtTime(1500, audioContext.currentTime);
            filter.frequency.exponentialRampToValueAtTime(300, audioContext.currentTime + duration);
            filter.Q.setValueAtTime(2, audioContext.currentTime);

            // Настройка громкости
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(volume, audioContext.currentTime + 0.005);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);

            // Подключаем цепочку
            oscillator.connect(filter);
            filter.connect(gainNode);
            gainNode.connect(audioContext.destination);

            // Запускаем звук
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration);
        }

        // Звуки игры
        const sounds = {
            // Старт хода
            startTurn: () => {
                playAudioFile(audioFiles.start, 0.8);
            },

            // Окончание хода/раунда
            endTurn: () => {
                playAudioFile(audioFiles.finish, 0.8);
            },

            

            // Предупреждение за 5 секунд
            warning5s: () => {
                playAudioFile(audioFiles.warning5s, 0.8);
            },

            // Клик кнопки (прочие кнопки)
            buttonClick: () => {
                playAudioFile(audioFiles.click, 0.5);
            },

            // Угадано слово - "done"
            wordGuessed: () => {
                playAudioFile(audioFiles.done, 0.8);
            },

            // Пропуск слова - "next"
            wordPassed: () => {
                playAudioFile(audioFiles.next, 0.8);
            }
        };

        // Воспроизведение звука
        function playSound(soundName) {
            if (!soundEnabled || !audioUnlocked) return;
            
            try {
                if (sounds[soundName]) {
                    sounds[soundName]();
                }
            } catch (error) {
                console.error('Ошибка воспроизведения звука:', error);
            }
        }

        // Включение/выключение звука
        function toggleSound() {
            soundEnabled = !soundEnabled;
            if (soundEnabled && !audioUnlocked) {
                unlockAudio();
            }
            console.log('Звук', soundEnabled ? 'включен' : 'выключен');
            return soundEnabled;
        }

        // Включение аудио с экрана разблокировки
        function enableAudio() {
            initAudio();
            loadAudioFiles();
            unlockAudio();
            soundEnabled = true;
            audioUnlocked = true;
            
            // Воспроизводим тестовый звук
            setTimeout(() => {
                playSound('buttonClick');
            }, 100);
            
            // Переходим к экрану настройки игры
            showScreen('setupScreen');
        }

        // Пропуск аудио
        function skipAudio() {
            soundEnabled = false;
            showScreen('setupScreen');
        }

        // Универсальная функция для кнопок с звуком
        function buttonClick(callback) {
            playSound('buttonClick');
            if (callback) callback();
        }

        // Удалены тестовые и переключаемые устаревшие звуки

        // Клиентский таймер с использованием performance.now()
        let timerState = {
            isRunning: false,
            isPaused: false,
            startTime: null,
            duration: 30000, // 30 секунд в миллисекундах
            remainingTime: 30000,
            animationFrameId: null,
            carriedTime: 0, // Перенесенное время между раундами
            roundStartTime: null, // Время начала раунда для корректного вычисления перенесенного времени
            pausedDuration: 0, // Общее время пауз в раунде
            pauseStartTime: null, // Время начала текущей паузы
            roundEndProcessed: false, // Флаг для предотвращения двойной обработки завершения раунда
            warningPlayed: false // Флаг для предотвращения повторного воспроизведения предупреждения
        };

        // Подключение к WebSocket
        function connectWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}`;
            
            ws = new WebSocket(wsUrl);
            
            ws.onopen = function() {
                console.log('WebSocket подключен');
                updateConnectionStatus(true);
            };
            
            ws.onmessage = function(event) {
                const message = JSON.parse(event.data);
                console.log('Получено сообщение:', message);
                console.log('Тип сообщения:', message.type);
                
                if (message.type === 'game_state') {
                    gameState = message.data;
                    console.log('Получен game_state с playerCarriedTime:', gameState.playerCarriedTime);
                    updateGameDisplay();
                    
                    // Проверяем, нужно ли показать экран представления игрока
                    const isOnRulesScreen = document.getElementById('rulesScreen2').classList.contains('active') || 
                                          document.getElementById('rulesScreen3').classList.contains('active');
                    const isOnRoundScoresScreen = document.getElementById('roundScoresScreen').classList.contains('active');
                    
                    if (isOnRulesScreen || isOnRoundScoresScreen) {
                        // Показываем экран представления игрока для нового раунда
                        showPlayerIntroScreen();
                    } else if (document.getElementById('gameScreen').classList.contains('active') && !timerState.isRunning) {
                        // Если мы на экране игры и таймер не запущен, запускаем его с учетом carriedTime
                        const currentPlayerCarriedTime = gameState.playerCarriedTime && gameState.currentPlayer 
                            ? (gameState.playerCarriedTime[gameState.currentPlayer.id] || 0)
                            : 0;
                        
                        console.log('Запускаем таймер после получения game_state:');
                        console.log('- currentPlayer:', gameState.currentPlayer);
                        console.log('- currentPlayerCarriedTime:', currentPlayerCarriedTime);
                        
                        // ИСПРАВЛЕНИЕ: Используем перенесенное время как основное время, если оно есть
                        // Если перенесенное время > 0, используем его как полное время таймера
                        // Иначе используем стандартное время раунда
                        const timerDuration = currentPlayerCarriedTime > 0 ? currentPlayerCarriedTime : gameSetup.roundDuration;
                        startTimer(timerDuration, currentPlayerCarriedTime);
                    }
                } else if (message.type === 'round_completed') {
                    console.log('Получено событие round_completed:', message.data);
                    // НЕ обновляем currentRound здесь - правильное значение придет в следующем game_state
                    // message.data.currentRound содержит номер завершенного раунда (1, 2, 3)
                    gameState.scores = message.data.scores;
                    
                    // Если таймер еще работает, значит раунд завершился по исчерпанию слов
                    // В этом случае нужно правильно вычислить перенесенное время
                    if (timerState.isRunning) {
                        endRoundByWordsExhausted();
                    }
                    // Если таймер уже остановлен, перенесенное время уже вычислено
                    
                    // Определяем, какой экран показать после завершения раунда
                    // message.data.currentRound содержит номер завершенного раунда (1, 2, 3)
                    const completedRound = message.data.currentRound;
                    
                    if (completedRound === 1) {
                        // Завершился первый раунд - сразу показываем экран правил 2-го раунда
                        showScreen('rulesScreen2');
                    } else if (completedRound === 2) {
                        // Завершился второй раунд - показываем экран правил 3-го раунда
                        showScreen('rulesScreen3');
                    } else if (completedRound === 3) {
                        // Завершился третий раунд - игра окончена, показываем результаты
                        showResults();
                    }
                } else if (message.type === 'game_ended') {
                    console.log('Получено событие game_ended:', message.data);
                    console.log('Счета команд в game_ended:', message.data.scores);
                    console.log('Статистика по раундам в game_ended:', message.data.teamStatsByRound);
                    gameState = message.data;
                    showResults();
                } else if (message.type === 'handoff_screen') {
                    console.log('Получено событие handoff_screen:', message.data);
                    showHandoffScreen(message.data);
                } else if (message.type === 'error') {
                    alert('Ошибка: ' + message.message);
                }
            };
            
            ws.onclose = function() {
                console.log('WebSocket отключен');
                updateConnectionStatus(false);
                // Попытка переподключения через 3 секунды
                setTimeout(connectWebSocket, 3000);
            };
            
            ws.onerror = function(error) {
                console.error('WebSocket ошибка:', error);
                updateConnectionStatus(false);
            };
        }

        function updateConnectionStatus(connected) {
            const status = document.getElementById('connectionStatus');
            if (connected) {
                status.textContent = 'Подключено';
                status.className = 'connection-status connected';
            } else {
                status.textContent = 'Отключено';
                status.className = 'connection-status disconnected';
            }
        }

        function sendEvent(type, data = {}) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type, data }));
            } else {
                console.error('WebSocket не подключен');
            }
        }

        function setupTeams() {
            const playerCount = parseInt(document.getElementById('playerCount').value);
            const teamCount = parseInt(document.getElementById('teamCount').value);
            const roundDuration = parseInt(document.getElementById('roundDuration').value);
            
            // Валидация количества игроков
            if (playerCount < 4 || playerCount > 20) {
                alert('Количество игроков должно быть от 4 до 20.');
                return;
            }
            
            // Создание игроков и команд
            const players = [];
            const teams = [];
            
            for (let i = 1; i <= playerCount; i++) {
                players.push({
                    id: `player_${i}`,
                    name: `Игрок ${i}`
                });
            }
            
            for (let i = 1; i <= teamCount; i++) {
                teams.push({
                    id: `team_${i}`,
                    name: `Команда ${i}`,
                    players: []
                });
            }
            
            // Распределение игроков по командам
            players.forEach((player, index) => {
                const teamIndex = index % teamCount;
                teams[teamIndex].players.push(player.id);
            });
            
            // Сохранение настроек
            gameSetup.players = players;
            gameSetup.teams = teams;
            gameSetup.roundDuration = roundDuration;
            
            // Отображение команд
            displayTeams();
            showScreen('teamsScreen');
        }

        function displayTeams() {
            const teamsList = document.getElementById('teamsList');
            teamsList.innerHTML = '';
            
            gameSetup.teams.forEach(team => {
                const teamDiv = document.createElement('div');
                teamDiv.className = 'team-item';
                
                const playersHtml = team.players.map(playerId => {
                    const player = gameSetup.players.find(p => p.id === playerId);
                    return `<span class="player-tag">${player.name}</span>`;
                }).join('');
                
                teamDiv.innerHTML = `
                    <h3>${team.name}</h3>
                    <div class="team-players">${playersHtml}</div>
                `;
                
                teamsList.appendChild(teamDiv);
            });
        }

        function shuffleTeams() {
            const playerCount = gameSetup.players.length;
            const teamCount = gameSetup.teams.length;
            
            // Очистка команд
            gameSetup.teams.forEach(team => {
                team.players = [];
            });
            
            // Случайное распределение игроков
            const shuffledPlayers = [...gameSetup.players].sort(() => Math.random() - 0.5);
            
            shuffledPlayers.forEach((player, index) => {
                const teamIndex = index % teamCount;
                gameSetup.teams[teamIndex].players.push(player.id);
            });
            
            displayTeams();
        }

        function setupWords() {
            showScreen('wordsScreen');
        }

        

        const ALL_CATEGORIES = [
            'Флора и фауна',
            'Знаменитости',
            'Природные явления',
            'География',
            'Техника',
            'Вещи и предметы быта',
            'Продукты питания и кулинария',
            'Материалы и вещества',
            'Развлечения и хобби',
            'Спорт и фитнес',
            'Профессии и должности',
            'Общество и бюрократия',
            'Здоровье и медицина',
            'Праздники, обычаи и традиции',
            'Цифровые продукты',
            'Фильмы и сериалы',
            'Книги и литература',
            'Фразеологизмы, пословицы и поговорки',
            'История',
            'Архитектура и городская среда',
            'Бренды и торговые марки',
            'Музыка',
            'Эмоции и черты характера',
            'Наука и технологии'
        ];

        function renderCategories() {
            const container = document.getElementById('categoriesContainer');
            container.innerHTML = '';
            ALL_CATEGORIES.forEach((cat, idx) => {
                const id = `cat_${idx}`;
                const item = document.createElement('label');
                item.style.display = 'flex';
                item.style.alignItems = 'center';
                item.style.gap = '12px';
                item.style.padding = '12px 14px';
                item.style.border = '1px solid rgba(255,255,255,0.18)';
                item.style.borderRadius = '12px';
                item.style.background = 'rgba(255,255,255,0.06)';
                item.style.backdropFilter = 'blur(2px)';
                item.style.minHeight = '52px';
                item.style.justifyContent = 'flex-start';
                item.innerHTML = `
                    <input type="checkbox" class="categoryBox" id="${id}" data-category="${cat}" checked style="width:26px;height:26px; accent-color:#ffeb3b;"> 
                    <span style="font-size:16px; line-height: 1.2;">${cat}</span>
                `;
                container.appendChild(item);
            });
        }

        function selectAllCategories(val) {
            document.querySelectorAll('#categoriesContainer .categoryBox').forEach(cb => {
                cb.checked = !!val;
            });
        }

        // Инициализация контейнера категорий при показе экрана слов
        const wordsScreenObserver = new MutationObserver(() => {
            const screen = document.getElementById('wordsScreen');
            if (screen && screen.style.display !== 'none') {
                renderCategories();
                initDifficultyControls();
                wordsScreenObserver.disconnect();
            }
        });
        wordsScreenObserver.observe(document.body, { childList: true, subtree: true });

        // Кэш для слов повышенной сложности
        let elevatedWordsCache = null;

        // Функция для проверки, является ли слово повышенной сложности
        function isWordElevated(word) {
            if (!word) return false;
            
            // Если кэш не загружен, загружаем его
            if (elevatedWordsCache === null) {
                loadElevatedWordsCache();
            }
            
            return elevatedWordsCache && elevatedWordsCache.has(word.toUpperCase());
        }

        // Загрузка кэша слов повышенной сложности
        function loadElevatedWordsCache() {
            fetch('/words.csv')
                .then(response => response.text())
                .then(csvText => {
                    const lines = csvText.split('\n');
                    elevatedWordsCache = new Set();
                    
                    lines.forEach(line => {
                        const parts = line.split(',');
                        if (parts.length >= 3 && parts[2].trim() === 'повышенный') {
                            elevatedWordsCache.add(parts[0].trim().toUpperCase());
                        }
                    });
                    
                    console.log('Загружено слов повышенной сложности:', elevatedWordsCache.size);
                })
                .catch(error => {
                    console.error('Ошибка загрузки words.csv:', error);
                    elevatedWordsCache = new Set();
                });
        }

        // Инициализация тумблера и слайдера сложности
        function initDifficultyControls() {
            const toggle = document.getElementById('difficultyToggle');
            const knob = document.getElementById('difficultyKnob');
            const slider = document.getElementById('difficultySlider');
            const sliderValue = document.getElementById('difficultySliderValue');
            
            if (!toggle || !knob || !slider || !sliderValue) return;

            const applyState = () => {
                const bg = toggle.checked ? '#2196F3' : '#666';
                knob.style.transform = toggle.checked ? 'translateX(26px)' : 'translateX(0)';
                knob.previousElementSibling.style.backgroundColor = bg;
                
                // При включении выставляем минимум 25%, при выключении — 0 и дизейблим
                if (toggle.checked) {
                    if (parseInt(slider.value, 10) === 0) {
                        slider.value = '25';
                    }
                    slider.disabled = false;
                } else {
                    slider.value = '0';
                    slider.disabled = true;
                }
                sliderValue.textContent = `${slider.value}%`;
            };

            // Всегда стартуем с дефолтных значений на каждом показе экрана
            toggle.checked = true;
            slider.value = '25';

            // Удаляем старые обработчики если они есть
            toggle.removeEventListener('change', applyState);
            slider.removeEventListener('input', handleSliderInput);

            // Добавляем обработчики
            toggle.addEventListener('change', applyState);
            slider.addEventListener('input', handleSliderInput);

            function handleSliderInput() {
                const v = Math.max(0, Math.min(100, Math.round(parseInt(slider.value, 10) / 5) * 5));
                slider.value = String(v);
                sliderValue.textContent = `${slider.value}%`;
                // Автовыключение тумблера при 0%
                if (v === 0 && toggle.checked) {
                    toggle.checked = false;
                    applyState();
                } else if (v > 0 && !toggle.checked) {
                    toggle.checked = true;
                    applyState();
                }
            }

            applyState();
        }

        function getSelectedCategories() {
            const list = [];
            document.querySelectorAll('#categoriesContainer .categoryBox:checked').forEach(cb => list.push(cb.getAttribute('data-category')));
            return list;
        }

        function getSelectedLevels() {
            const toggle = document.getElementById('difficultyToggle');
            if (!toggle) return ['обычный', 'повышенный'];
            return toggle.checked ? ['обычный', 'повышенный'] : ['обычный'];
        }

        function startGame() {
            const wordsCount = parseInt(document.getElementById('wordsCount').value);
            gameSetup.wordsCount = wordsCount;
            const selectedCategories = getSelectedCategories();
            const selectedLevels = getSelectedLevels();
            const slider = document.getElementById('difficultySlider');
            const hardPercentage = slider ? Math.max(0, Math.min(100, parseInt(slider.value, 10) || 0)) : 0;
            
            // Очищаем перенесенное время при начале новой игры
            clearCarriedTime();
            
            
            
            sendEvent('start_game', {
                players: gameSetup.players,
                teams: gameSetup.teams,
                roundDuration: gameSetup.roundDuration,
                wordsCount: gameSetup.wordsCount,
                categories: selectedCategories.length ? selectedCategories : undefined,
                levels: selectedLevels.length ? selectedLevels : undefined,
                hardPercentage: hardPercentage
            });
            
            // Показываем экран правил первого раунда вместо прямого перехода к игре
            showScreen('rulesScreen1');
            // На старте игры гарантируем снятие любой блокировки
            toggleButtonsDuringPause(false);
        }

        // Функции для экранов правил
        function startFirstRound() {
            // Показываем экран представления первого игрока
            showPlayerIntroScreen();
        }

        function startSecondRound() {
            // Переходим к следующему раунду
            sendEvent('continue_round');
            console.log('startSecondRound - ждем обновления game_state для показа экрана представления игрока');
            // Экран представления игрока будет показан после получения обновленного game_state
        }

        function startThirdRound() {
            // Переходим к следующему раунду
            sendEvent('continue_round');
            console.log('startThirdRound - ждем обновления game_state для показа экрана представления игрока');
            // Экран представления игрока будет показан после получения обновленного game_state
        }


        function wordGuessed() {
            const currentTeam = getCurrentTeam();
            if (currentTeam) {
                // Воспроизводим звук угадывания
                playSound('wordGuessed');
                sendEvent('word_guessed', { teamId: currentTeam.id });
            }
        }

        function wordPassed() {
            const currentTeam = getCurrentTeam();
            if (currentTeam) {
                // Воспроизводим звук пропуска
                playSound('wordPassed');
                sendEvent('word_passed', { teamId: currentTeam.id });
            }
        }

        function pauseGame() {
            const pauseBtn = document.getElementById('pauseBtn');
            // Воспроизводим звук клика кнопки
            playSound('buttonClick');
            
            if (timerState.isPaused) {
                sendEvent('resume_game');
                pauseBtn.textContent = '⏸️';
                resumeTimer();
                toggleButtonsDuringPause(false);
            } else {
                sendEvent('pause_game');
                pauseBtn.textContent = '▶️';
                pauseTimer();
                toggleButtonsDuringPause(true);
            }
        }

        // Блокировка всех кнопок во время паузы, кроме паузы и завершения игры
        function toggleButtonsDuringPause(isPaused) {
            try {
                const allButtons = document.querySelectorAll('button');
                allButtons.forEach((btn) => {
                    const isPauseButton = btn.id === 'pauseBtn';
                    const isEndButton = btn.classList && btn.classList.contains('end-btn');
                    if (isPauseButton || isEndButton) {
                        btn.disabled = false;
                    } else {
                        btn.disabled = !!isPaused;
                    }
                });
            } catch (e) {
                console.warn('toggleButtonsDuringPause error:', e);
            }
        }

        function endGame() {
            if (confirm('Вы уверены, что хотите завершить игру?')) {
                // Останавливаем таймер
                stopTimer();
                // Сбрасываем состояние таймера
                resetTimer();
                // Снимаем блокировку кнопок при завершении игры
                toggleButtonsDuringPause(false);
                // Переходим на экран настроек игры
                showScreen('setupScreen');
            }
        }

        function newGame() {
            showScreen('setupScreen');
            stopTimer();
            // Сброс настроек игры
            gameSetup = {
                players: [],
                teams: [],
                roundDuration: 30,
                wordsCount: 100
            };
            // Сброс состояния таймера
            resetTimer();
            // Снимаем блокировку кнопок при инициализации новой игры
            toggleButtonsDuringPause(false);
        }

        function getCurrentTeam() {
            if (!gameState.teams || !gameState.currentPlayer) return null;
            
            for (const team of gameState.teams) {
                if (team.players && team.players.includes(gameState.currentPlayer.id)) {
                    return team;
                }
            }
            return null;
        }

        function updateGameDisplay() {
            // Обновление информации о раунде
            const roundInfo = document.getElementById('roundInfo');
            if (gameState.currentRound !== undefined) {
                console.log('Обновление отображения раунда:', gameState.currentRound, 'отображается как:', gameState.currentRound + 1);
                roundInfo.textContent = `Текущий раунд: ${gameState.currentRound + 1} из 3`;
            }
            
            // Обновление информации об игроке
            const playerInfo = document.getElementById('playerInfo');
            if (gameState.currentPlayer) {
                // Находим команду игрока
                const playerTeam = gameState.teams.find(team => 
                    team.players && team.players.includes(gameState.currentPlayer.id)
                );
                
                if (playerTeam) {
                    playerInfo.textContent = `Ход: ${gameState.currentPlayer.name} (${playerTeam.name})`;
                } else {
                    playerInfo.textContent = `Ход: ${gameState.currentPlayer.name}`;
                }
            }
            
            // Обновление количества оставшихся слов
            const wordsCounter = document.getElementById('wordsCounter');
            if (gameState.availableWords !== undefined) {
                // Отнимаем единицу, так как текущее слово уже показано
                const wordsLeft = Math.max(0, gameState.availableWords.length - 1);
                wordsCounter.textContent = `Еще слов - ${wordsLeft}`;
                
                // Меняем цвет в зависимости от количества слов
                if (wordsLeft <= 10) {
                    wordsCounter.style.color = '#ff6b6b'; // Красный когда мало слов
                } else if (wordsLeft <= 25) {
                    wordsCounter.style.color = '#ff9800'; // Оранжевый когда среднее количество
                } else {
                    wordsCounter.style.color = '#ffeb3b'; // Желтый когда много слов
                }
            }
            
            // Обновление текущего слова
            const currentWord = document.getElementById('currentWord');
            if (gameState.currentWord) {
                currentWord.textContent = gameState.currentWord;
                // Debug-подсветка слов повышенной сложности
                if (window.__hatDebug && window.__hatDebug.highlightElevated) {
                    // Проверяем уровень сложности из gameState или используем fallback
                    const isElevated = gameState.currentWordLevel === 'повышенный' || 
                                     (gameState.currentWord && isWordElevated(gameState.currentWord));
                    if (isElevated) {
                        currentWord.style.color = '#000000';
                        currentWord.style.backgroundColor = '#ffff00'; // Желтый фон для лучшей видимости
                    } else {
                        currentWord.style.color = '';
                        currentWord.style.backgroundColor = '';
                    }
                } else {
                    currentWord.style.color = '';
                    currentWord.style.backgroundColor = '';
                }
            } else {
                currentWord.textContent = 'Загрузка...';
                currentWord.style.color = '';
                currentWord.style.backgroundColor = '';
            }

        }

        function updateScores() {
            const scoresContainer = document.getElementById('scores');
            scoresContainer.innerHTML = '';
            
            if (gameState.teams && gameState.scores) {
                gameState.teams.forEach(team => {
                    const scoreDiv = document.createElement('div');
                    scoreDiv.className = 'score-item';
                    scoreDiv.innerHTML = `
                        <h3>${team.name}</h3>
                        <div class="score">${gameState.scores[team.id] || 0}</div>
                    `;
                    scoresContainer.appendChild(scoreDiv);
                });
            }
        }

        function showRoundScores() {
            const roundScores = document.getElementById('roundScores');
            
            // Показываем результаты команд
            roundScores.innerHTML = '';
            if (gameState.teams && gameState.scores) {
                gameState.teams.forEach(team => {
                    const scoreDiv = document.createElement('div');
                    scoreDiv.className = 'score-item';
                    scoreDiv.innerHTML = `
                        <h3>${team.name}</h3>
                        <div class="score">${gameState.scores[team.id] || 0}</div>
                    `;
                    roundScores.appendChild(scoreDiv);
                });
            }
            
            // Показываем перенесенное время для текущего игрока
            const currentPlayerCarriedTime = gameState.playerCarriedTime && gameState.currentPlayer 
                ? (gameState.playerCarriedTime[gameState.currentPlayer.id] || 0)
                : 0;
            
            if (currentPlayerCarriedTime > 0) {
                const timeInfo = document.createElement('div');
                timeInfo.className = 'score-item';
                timeInfo.style.marginTop = '20px';
                timeInfo.innerHTML = `
                    <h3>Перенесено времени</h3>
                    <div class="score">${currentPlayerCarriedTime} сек</div>
                `;
                roundScores.appendChild(timeInfo);
            }
        }

        function continueToNextRound() {
            const nextRound = gameState.currentRound + 1;
            
            if (nextRound > 3) {
                // Игра завершена, показываем финальные результаты
                showResults();
            } else {
                // После первого раунда показываем правила второго раунда вместо мгновенного старта
                if (nextRound === 2) {
                    showScreen('rulesScreen2');
                } else {
                    // Для переходов, не требующих экрана правил, продолжаем сразу
                    sendEvent('continue_round');
                    showScreen('gameScreen');
                    console.log('continueToNextRound - ждем обновления game_state для запуска таймера');
                    // Таймер будет запущен после получения обновленного game_state
                }
            }
        }

        function showResults() {
            // Определяем победителя
            determineWinner();
            
            // Показываем экран статистики команд по умолчанию
            showTeamStats();
        }

        function determineWinner() {
            const winner = document.getElementById('winner');
            
            if (gameState.teams && gameState.teamStatsByRound) {
                let maxScore = -Infinity;
                let winnerTeam = null;
                let teamsWithMaxScore = [];
                
                // Находим максимальный счет (сумма по всем раундам)
                gameState.teams.forEach(team => {
                    const round1Score = gameState.teamStatsByRound[0][team.id] || 0;
                    const round2Score = gameState.teamStatsByRound[1][team.id] || 0;
                    const round3Score = gameState.teamStatsByRound[2][team.id] || 0;
                    const totalScore = round1Score + round2Score + round3Score;
                    
                    if (totalScore > maxScore) {
                        maxScore = totalScore;
                    }
                });
                
                // Находим все команды с максимальным счетом
                gameState.teams.forEach(team => {
                    const round1Score = gameState.teamStatsByRound[0][team.id] || 0;
                    const round2Score = gameState.teamStatsByRound[1][team.id] || 0;
                    const round3Score = gameState.teamStatsByRound[2][team.id] || 0;
                    const totalScore = round1Score + round2Score + round3Score;
                    
                    if (totalScore === maxScore) {
                        teamsWithMaxScore.push(team);
                    }
                });
                
                // Определяем результат
                if (teamsWithMaxScore.length === 1) {
                    // Есть единственный победитель
                    winnerTeam = teamsWithMaxScore[0];
                    winner.textContent = `🏆 Победила ${winnerTeam.name}!`;
                } else {
                    // Ничья
                    winner.textContent = `🤝 Ничья!`;
                }
            }
        }

        function showTeamStats() {
            // Обновляем навигацию
            document.querySelectorAll('.stats-navigation .btn').forEach(btn => {
                btn.classList.remove('btn-active');
            });
            document.querySelectorAll('.stats-navigation .btn')[0].classList.add('btn-active');
            
            // Заполняем таблицу статистики команд
            const teamStatsBody = document.getElementById('teamStatsBody');
            teamStatsBody.innerHTML = '';
            
            console.log('showTeamStats - gameState.scores:', gameState.scores);
            console.log('showTeamStats - gameState.teamStatsByRound:', gameState.teamStatsByRound);
            
            if (gameState.teams && gameState.teamStatsByRound) {
                gameState.teams.forEach(team => {
                    const row = document.createElement('tr');
                    
                    const round1Score = gameState.teamStatsByRound[0][team.id] || 0;
                    const round2Score = gameState.teamStatsByRound[1][team.id] || 0;
                    const round3Score = gameState.teamStatsByRound[2][team.id] || 0;
                    const totalScore = round1Score + round2Score + round3Score;
                    const serverTotalScore = gameState.scores[team.id] || 0;
                    
                    console.log(`Команда ${team.name}: раунд1=${round1Score}, раунд2=${round2Score}, раунд3=${round3Score}, сумма=${totalScore}, сервер=${serverTotalScore}`);
                    
                    row.innerHTML = `
                        <td><strong>${team.name || 'Команда'}</strong></td>
                        <td class="${getScoreClass(round1Score)}">${round1Score}</td>
                        <td class="${getScoreClass(round2Score)}">${round2Score}</td>
                        <td class="${getScoreClass(round3Score)}">${round3Score}</td>
                        <td class="${getScoreClass(totalScore)}"><strong>${totalScore}</strong></td>
                    `;
                    
                    teamStatsBody.appendChild(row);
                });
            }
            
            // Показываем экран статистики команд
            showScreen('teamResultsScreen');
        }

        function showPlayerStats() {
            // Обновляем навигацию
            document.querySelectorAll('.stats-navigation .btn').forEach(btn => {
                btn.classList.remove('btn-active');
            });
            document.querySelectorAll('.stats-navigation .btn')[1].classList.add('btn-active');
            
            // Заполняем таблицу статистики игроков
            const playerStatsBody = document.getElementById('playerStatsBody');
            playerStatsBody.innerHTML = '';
            
            if (gameState.players && gameState.playerStats) {
                // Сортируем игроков по очкам (по убыванию)
                const sortedPlayers = [...gameState.players].sort((a, b) => {
                    const scoreA = gameState.playerStats[a.id]?.totalScore || 0;
                    const scoreB = gameState.playerStats[b.id]?.totalScore || 0;
                    return scoreB - scoreA;
                });
                
                sortedPlayers.forEach(player => {
                    const stats = gameState.playerStats[player.id] || { guessed: 0, passed: 0, totalScore: 0 };
                    
                    // Находим команду игрока
                    const playerTeam = gameState.teams.find(team => 
                        team.players && team.players.includes(player.id)
                    );
                    const teamName = playerTeam ? playerTeam.name : 'Неизвестно';
                    
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td><strong>${player.name || 'Игрок'}</strong></td>
                        <td class="${getScoreClass(stats.totalScore)}"><strong>${stats.totalScore}</strong></td>
                    `;
                    
                    playerStatsBody.appendChild(row);
                });
            }
            
            // Показываем экран статистики игроков
            showScreen('playerResultsScreen');
        }

        function getScoreClass(score) {
            if (score > 0) return 'score-positive';
            if (score < 0) return 'score-negative';
            return 'score-zero';
        }

        function showScreen(screenId) {
            document.querySelectorAll('.screen').forEach(screen => {
                screen.classList.remove('active');
            });
            document.getElementById(screenId).classList.add('active');
        }

        // Функции для работы с переносом времени в localStorage
        function saveCarriedTime(timeLeft) {
            if (timeLeft > 0) {
                localStorage.setItem('hatGame_carriedTime', timeLeft.toString());
                console.log('Сохранено перенесенное время:', timeLeft, 'секунд');
            } else {
                localStorage.removeItem('hatGame_carriedTime');
                console.log('Перенесенное время очищено');
            }
        }

        function loadCarriedTime() {
            const saved = localStorage.getItem('hatGame_carriedTime');
            const carriedTime = saved ? parseFloat(saved) : 0;
            console.log('Загружено перенесенное время:', carriedTime, 'секунд');
            return carriedTime;
        }

        function clearCarriedTime() {
            localStorage.removeItem('hatGame_carriedTime');
            console.log('Перенесенное время очищено');
        }

        // Функция для корректного вычисления перенесенного времени
        function calculateCarriedTime() {
            // Используем уже вычисленное оставшееся время из таймера
            // timerState.remainingTime уже учитывает паузы и корректно вычислено
            const carriedTime = Math.max(0, timerState.remainingTime);
            
            console.log('calculateCarriedTime:', {
                remainingTime: Math.round(timerState.remainingTime / 1000) + 's',
                duration: Math.round(timerState.duration / 1000) + 's',
                carriedTime: Math.round(carriedTime / 1000) + 's',
                isRunning: timerState.isRunning,
                isPaused: timerState.isPaused
            });

            return Math.ceil(carriedTime / 1000); // Возвращаем в секундах
        }

        // Функция для завершения раунда по исчерпанию слов
        function endRoundByWordsExhausted() {
            console.log('Раунд завершен по исчерпанию слов');
            
            // Проверяем, что раунд еще не был обработан
            if (timerState.roundEndProcessed) {
                console.log('Завершение раунда уже обработано, пропускаем');
                return;
            }
            
            // Проверяем, что таймер действительно работал
            if (!timerState.isRunning) {
                console.log('Таймер уже остановлен, пропускаем вычисление перенесенного времени');
                return;
            }
            
            // Устанавливаем флаг, что раунд обработан
            timerState.roundEndProcessed = true;
            
            // Останавливаем таймер
            stopTimer();
            
            // Вычисляем перенесенное время на основе оставшегося времени
            let carriedTime = calculateCarriedTime();
            
            // ИСПРАВЛЕНИЕ: Проверяем, что перенесенное время разумное (не больше стандартного времени раунда)
            if (carriedTime > gameSetup.roundDuration) {
                console.log('Перенесенное время больше стандартного времени раунда, устанавливаем 0');
                carriedTime = 0;
            }
            
            // Сохраняем перенесенное время в localStorage
            saveCarriedTime(carriedTime);
            
            // Отправляем информацию о перенесенном времени на сервер
            if (carriedTime > 0) {
                sendEvent('round_completed_carried_time', { carriedTime: carriedTime });
            }
            
            console.log('Перенесенное время при завершении раунда:', carriedTime, 'секунд');
        }

        // Новые функции для работы с таймером
        function startTimer(durationSeconds, carriedTimeSeconds = 0) {
            stopTimer();
            
            console.log('startTimer вызван с параметрами:', { durationSeconds, carriedTimeSeconds });
            
            // ИСПРАВЛЕНИЕ: durationSeconds уже содержит правильное время (либо перенесенное, либо стандартное)
            // carriedTimeSeconds используется только для логирования и очистки localStorage
            const actualDuration = durationSeconds;
            const totalDuration = actualDuration * 1000;
            
            console.log('startTimer - carriedTimeSeconds:', carriedTimeSeconds, 'actualDuration:', actualDuration, 'totalDuration:', totalDuration);
            
            timerState.duration = totalDuration;
            timerState.remainingTime = totalDuration;
            timerState.startTime = performance.now();
            timerState.roundStartTime = performance.now(); // Фиксируем время начала раунда
            timerState.pausedDuration = 0; // Сбрасываем время пауз
            timerState.isRunning = true;
            timerState.isPaused = false;
            timerState.carriedTime = 0; // Сбрасываем перенесенное время после использования
            timerState.roundEndProcessed = false; // Сбрасываем флаг завершения раунда
            timerState.warningPlayed = false; // Сбрасываем флаг предупреждения
            
            // Воспроизводим звук старта хода
            playSound('startTurn');
            
            // Если использовали перенесенное время, очищаем его из localStorage
            if (carriedTimeSeconds > 0) {
                clearCarriedTime();
                console.log('Использовано перенесенное время:', carriedTimeSeconds, 'секунд');
            }
            
            updateTimerDisplay();
            timerLoop();
        }

        function stopTimer() {
            timerState.isRunning = false;
            timerState.isPaused = false;
            if (timerState.animationFrameId) {
                cancelAnimationFrame(timerState.animationFrameId);
                timerState.animationFrameId = null;
            }
        }

        function pauseTimer() {
            if (timerState.isRunning && !timerState.isPaused) {
                timerState.isPaused = true;
                timerState.pauseStartTime = performance.now(); // Фиксируем время начала паузы
                if (timerState.animationFrameId) {
                    cancelAnimationFrame(timerState.animationFrameId);
                    timerState.animationFrameId = null;
                }
            }
        }

        function resumeTimer() {
            if (timerState.isRunning && timerState.isPaused) {
                timerState.isPaused = false;
                // Добавляем время паузы к общему времени пауз
                if (timerState.pauseStartTime) {
                    timerState.pausedDuration += performance.now() - timerState.pauseStartTime;
                    timerState.pauseStartTime = null;
                }
                // Корректируем время начала с учетом паузы
                timerState.startTime = performance.now() - (timerState.duration - timerState.remainingTime);
                timerLoop();
            }
        }

        function resetTimer() {
            stopTimer();
            timerState = {
                isRunning: false,
                isPaused: false,
                startTime: null,
                duration: 30000,
                remainingTime: 30000,
                animationFrameId: null,
                carriedTime: 0,
                roundStartTime: null,
                pausedDuration: 0,
                pauseStartTime: null,
                roundEndProcessed: false,
                warningPlayed: false
            };
        }

        function timerLoop() {
            if (!timerState.isRunning || timerState.isPaused) {
                return;
            }

            const now = performance.now();
            const elapsed = now - timerState.startTime;
            timerState.remainingTime = Math.max(0, timerState.duration - elapsed);

            // Проверяем предупреждения
            const secondsLeft = Math.ceil(timerState.remainingTime / 1000);
            if (secondsLeft === 5 && !timerState.warningPlayed) {
                playSound('warning5s');
                timerState.warningPlayed = true;
            }

            updateTimerDisplay();

            if (timerState.remainingTime <= 0) {
                timerState.isRunning = false;
                playSound('endTurn');
                const carriedTime = 0;
                saveCarriedTime(carriedTime);
                sendEvent('time_up', { carriedTime: carriedTime });
            } else {
                timerState.animationFrameId = requestAnimationFrame(timerLoop);
            }
        }

        function updateTimerDisplay() {
            const seconds = Math.ceil(timerState.remainingTime / 1000);
            document.getElementById('timer').textContent = seconds;
        }

        function showPlayerIntroScreen() {
            // Останавливаем таймер
            stopTimer();
            
            // Обновляем информацию о текущем игроке
            const currentPlayerName = document.getElementById('currentPlayerName');
            const currentPlayerTeam = document.getElementById('currentPlayerTeam');
            
            if (gameState.currentPlayer) {
                currentPlayerName.textContent = gameState.currentPlayer.name;
                
                // Находим команду игрока
                const playerTeam = gameState.teams.find(team => 
                    team.players && team.players.includes(gameState.currentPlayer.id)
                );
                if (playerTeam) {
                    currentPlayerTeam.textContent = playerTeam.name;
                } else {
                    currentPlayerTeam.textContent = '';
                }
            }
            
            // Показываем экран представления игрока
            showScreen('playerIntroScreen');
        }

        function showHandoffScreen(data) {
            // Останавливаем таймер
            stopTimer();
            
            // Обновляем информацию о следующем игроке
            const nextPlayerName = document.getElementById('nextPlayerName');
            const nextPlayerTeam = document.getElementById('nextPlayerTeam');
            
            if (data.nextPlayer) {
                nextPlayerName.textContent = data.nextPlayer.name;
                
                // Находим команду игрока
                const playerTeam = gameState.teams.find(team => 
                    team.players && team.players.includes(data.nextPlayer.id)
                );
                if (playerTeam) {
                    nextPlayerTeam.textContent = playerTeam.name;
                } else {
                    nextPlayerTeam.textContent = '';
                }
            }
            
            // Показываем экран передачи хода
            showScreen('handoffScreen');
        }

        function startPlayerTurn() {
            // Переходим к экрану игры
            showScreen('gameScreen');
            
            // Запускаем таймер для хода игрока (с автоматической загрузкой перенесенного времени)
            const currentPlayerCarriedTime = gameState.playerCarriedTime && gameState.currentPlayer 
                ? (gameState.playerCarriedTime[gameState.currentPlayer.id] || 0)
                : 0;
            
            console.log('startPlayerTurn - currentPlayerCarriedTime:', currentPlayerCarriedTime);
            
            // ИСПРАВЛЕНИЕ: Используем перенесенное время как основное время, если оно есть
            // Если перенесенное время > 0, используем его как полное время таймера
            // Иначе используем стандартное время раунда
            const timerDuration = currentPlayerCarriedTime > 0 ? currentPlayerCarriedTime : gameSetup.roundDuration;
            startTimer(timerDuration, currentPlayerCarriedTime);
        }

        function startNextTurn() {
            // Отправляем событие о начале следующего хода
            sendEvent('start_next_turn');
            
            // Возвращаемся к экрану игры
            showScreen('gameScreen');
            
            // Загружаем перенесенное время из localStorage для нового хода
            const carriedTime = loadCarriedTime();
            
            // ИСПРАВЛЕНИЕ: Используем перенесенное время как основное время, если оно есть
            // Если перенесенное время > 0, используем его как полное время таймера
            // Иначе используем стандартное время раунда
            const timerDuration = carriedTime > 0 ? carriedTime : gameSetup.roundDuration;
            startTimer(timerDuration, carriedTime);
        }

        // Валидация количества игроков при изменении
        function validatePlayerCount() {
            const playerCountSelect = document.getElementById('playerCount');
            const playerCount = parseInt(playerCountSelect.value);
            
            if (playerCount < 4 || playerCount > 20) {
                alert('Количество игроков должно быть от 4 до 20.');
                // Устанавливаем значение по умолчанию
                playerCountSelect.value = '4';
            }
        }

        // Обработка изменения видимости страницы для корректировки таймера
        document.addEventListener('visibilitychange', function() {
            if (!document.hidden && timerState.isRunning && !timerState.isPaused) {
                // Страница снова видима, корректируем таймер
                const now = performance.now();
                const elapsed = now - timerState.startTime;
                timerState.remainingTime = Math.max(0, timerState.duration - elapsed);
                updateTimerDisplay();
            }
        });

        // Инициализация при загрузке страницы
        document.addEventListener('DOMContentLoaded', function() {
            connectWebSocket();
            // Инициализируем контролы сложности (без восстановления из localStorage)
            setTimeout(initDifficultyControls, 100);
            
            // Debug-панель: подсветка слов повышенной сложности
            (function initDebugPanel(){
                const stored = localStorage.getItem('hat_debug_highlight_elevated');
                window.__hatDebug = { highlightElevated: stored === '1' };
                const panel = document.createElement('div');
                panel.style.position = 'fixed';
                panel.style.right = '8px';
                panel.style.bottom = '8px';
                panel.style.padding = '6px 10px';
                panel.style.background = 'rgba(0,0,0,0.5)';
                panel.style.color = '#fff';
                panel.style.fontSize = '12px';
                panel.style.borderRadius = '6px';
                panel.style.zIndex = '9999';
                panel.style.userSelect = 'none';
                panel.style.cursor = 'default';
                panel.style.display = 'inline-flex';
                panel.style.alignItems = 'center';
                panel.style.gap = '6px';
                const label = document.createElement('label');
                label.style.display = 'inline-flex';
                label.style.alignItems = 'center';
                label.style.gap = '6px';
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.checked = !!window.__hatDebug.highlightElevated;
                checkbox.addEventListener('change', () => {
                    window.__hatDebug.highlightElevated = checkbox.checked;
                    localStorage.setItem('hat_debug_highlight_elevated', checkbox.checked ? '1' : '0');
                    updateGameDisplay();
                });
                const span = document.createElement('span');
                span.textContent = 'Debug: подсветка сложных слов';
                label.appendChild(checkbox);
                label.appendChild(span);
                panel.appendChild(label);

                document.body.appendChild(panel);
            })();
            
            // Добавляем валидацию при изменении количества игроков
            const playerCountSelect = document.getElementById('playerCount');
            if (playerCountSelect) {
                playerCountSelect.addEventListener('change', validatePlayerCount);
            }
            // На инициализации страницы снимаем любую возможную блокировку
            if (typeof toggleButtonsDuringPause === 'function') {
                toggleButtonsDuringPause(false);
            }
        });
    </script>
</body>
</html>
