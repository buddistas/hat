# Технические заметки - Hat Web

## Архитектура системы

### WebSocket события
```javascript
// Клиент → Сервер
'start_game'     // Начать игру
'next_word'      // Следующее слово
'word_guessed'   // Слово угадано
'word_passed'    // Пас
'pause_game'     // Пауза
'resume_game'    // Продолжить

// Сервер → Клиент
'game_state'     // Текущее состояние игры
'error'          // Ошибка
'game_ended'     // Игра завершена
```

#### Порядок событий при завершении раунда

Для корректного учета последнего угаданного слова сервер всегда отправляет события в таком порядке:
1) `game_state` — с уже обновленными `scores`, `teamStatsByRound`, `usedWords`;
2) `round_completed` — триггер перехода клиентского UI: после раунда 1 сразу показывается экран правил 2‑го раунда; после раунда 2 — экран правил 3‑го.

Это касается как автоматического завершения (последнее слово), так и ручного `end_round`.
Реализация: `src/infrastructure/GameService.js` в методах `handleWordGuessed` и `handleEndRound`.

### Структура gameState
```javascript
{
  gameId: string,
  players: Array<{id: string, name: string, teamId: string}>,
  teams: Array<{id: string, name: string, playerIds: string[]}>,
  currentRound: 0 | 1 | 2,
  currentPlayer: {id: string, name: string, teamId: string},
  currentWord: string | null,
  availableWords: string[],
  usedWords: string[],
  teamStatsByRound: {
    0: {[teamId: string]: number},
    1: {[teamId: string]: number}, 
    2: {[teamId: string]: number}
  },
  playerStats: {
    [playerId: string]: {
      guessed: number,
      passed: number,
      totalScore: number
    }
  },
  playerCarriedTime: {[playerId: string]: number} // секунды; очищается при завершении игры
}
```

## Локальная статистика игровой сессии

### Обзор

Статистика игровой сессии собирается **локально в браузере** и не зависит от сервера. Это обеспечивает полную автономность и мгновенное отображение данных без сетевых запросов.

### Архитектура

#### Хранение данных
- **Переменная**: `sessionStats` в JavaScript
- **Жизненный цикл**: Создается при начале игры, обновляется во время игры, очищается при новой игре
- **Независимость**: Полностью автономная система без серверных зависимостей

#### Функции сбора данных
```javascript
// Инициализация при начале игры
initSessionStats()

// Сбор данных во время игры
onWordShown(word)      // Фиксация времени показа слова
onWordGuessed()        // Обновление времени при угадывании
onWordPassed()         // Увеличение счетчика пропусков
onRoundStarted(round)  // Начало отсчета времени раунда
onRoundEnded(round)    // Фиксация продолжительности раунда
onGameEnded()          // Расчет фактов и общей статистики
```

#### Финализация последнего слова
- Введена функция `finalizeCurrentWordDisplay()` — суммирует время для `_currentWord` при завершении хода/раунда/игры.
- Точки вызова: `onRoundEnded`, `endRoundByWordsExhausted`, `timerLoop` (при `remainingTime <= 0`), `onGameEnded`.
- Это гарантирует, что слово, оставшееся на экране в момент завершения, учитывается в `wordDisplayTime` и попадает в «Самое сложное слово».

#### Интеграция с игровыми событиями
- **Показ слов**: `updateGameDisplay()` → `onWordShown()`
- **Угадывание**: `wordGuessed()` → `onWordGuessed()`
- **Пропуск**: `wordPassed()` → `onWordPassed()`
- **Начало раундов**: `startFirstRound()`, `startSecondRound()`, `startThirdRound()` → `onRoundStarted()`
- **Завершение раундов**: WebSocket `round_completed` → `onRoundEnded()`
- **Завершение игры**: WebSocket `game_ended` → `onGameEnded()`

### Структура данных
```javascript
let sessionStats = {
  gameId: string,
  startedAt: number,
  endedAt: number,
  duration: {
    roundDurations: { 0: number, 1: number, 2: number },
    totalGameDuration: number
  },
  facts: {
    mostPassedWord: { word: string, count: number },
    hardestWord: { word: string, totalTimeSeconds: number }
  },
  wordTracking: {
    passedWords: { [word: string]: number },
    wordDisplayTime: { [word: string]: number }
  },
  // Временные переменные для отслеживания
  _currentWord: string | null,
  _wordShownAt: number | null,
  _roundStartTime: number | null,
  _gameStartTime: number
}
```

### Особенности
- **Автономность**: Работает без интернета и сервера
- **Мгновенность**: Данные доступны сразу после завершения игры
- **Точность**: Сбор данных в реальном времени во время игры
- **Производительность**: Минимальное влияние на производительность игры

### Отображение времени (live total)
- Пока игра не завершена, «Общее время» на экране статистики равно сумме `roundDurations[0..2]`.
- После завершения игры используется `totalGameDuration`.

## Реализация переноса времени на клиенте

### Обзор

Реализована логика переноса остатка времени между раундами игры исключительно на стороне клиента, без зависимости от сервера. Это обеспечивает полную автономность игры и минимизирует зависимость от интернета.

### Архитектура

#### Хранение данных
- **localStorage**: Используется для сохранения перенесенного времени между раундами
- **Ключ**: `hatGame_carriedTime`
- **Формат**: Строковое представление числа секунд

#### Функции

##### `saveCarriedTime(timeLeft)`
- Сохраняет перенесенное время в localStorage
- Если `timeLeft > 0` - сохраняет значение
- Если `timeLeft <= 0` - удаляет ключ из localStorage
- **Параметры**: `timeLeft` (number) - количество секунд для переноса
- **Возвращает**: void

##### `loadCarriedTime()`
- Загружает перенесенное время из localStorage
- Возвращает 0, если время не сохранено
- **Параметры**: нет
- **Возвращает**: number - количество секунд

##### `clearCarriedTime()`
- Удаляет перенесенное время из localStorage
- Используется при начале новой игры или после использования времени
- **Параметры**: нет
- **Возвращает**: void

### Интеграция с игровой логикой

#### Завершение раунда
```javascript
// При завершении раунда
const carriedTime = Math.ceil(timerState.remainingTime / 1000);
saveCarriedTime(carriedTime);
```

#### Начало нового раунда
```javascript
// При запуске таймера
const loadedCarriedTime = loadCarriedTime();
// Минимум 5 секунд при старте 2-го и 3-го раундов применяется на стороне сервера в Game.startNextRound()
// На клиенте значения всегда в секундах
const actualDuration = loadedCarriedTime > 0 ? loadedCarriedTime : durationSeconds;

if (loadedCarriedTime > 0) {
    clearCarriedTime(); // Очищаем после использования
}
```

#### Начало новой игры
```javascript
// При старте новой игры
clearCarriedTime(); // Очищаем все перенесенное время
```

### Логика работы

1. **Завершение раунда по истечению времени**: 
   - Перенесенное время = 0 (время истекло)
   - Время сохраняется в localStorage
   - Отправляется событие на сервер (для совместимости)

2. **Завершение раунда по исчерпанию слов**:
   - Вычисляется остаток времени на основе `timerState.remainingTime`
   - Время сохраняется в localStorage
   - Отправляется событие на сервер (для совместимости)

3. **Начало нового раунда**:
   - Загружается перенесенное время из localStorage
   - Если есть перенесенное время - используется только оно
   - Если нет - используется стандартное время раунда
   - Перенесенное время очищается после использования

4. **Начало новой игры**:
   - Все перенесенное время очищается

### Преимущества

- ✅ **Автономность**: Игра работает без интернета
- ✅ **Простота**: Нет серверной инфраструктуры для времени
- ✅ **Надежность**: Нет зависимости от сетевого соединения
- ✅ **Быстродействие**: Мгновенные переходы между раундами
- ✅ **Совместимость**: Сохранена совместимость с серверной логикой

### Тестирование

Создан тестовый файл `test_time_carry.html` для проверки:
- Сохранения времени
- Загрузки времени
- Полного цикла переноса
- Информации о localStorage

### Совместимость

Реализация сохраняет совместимость с существующей серверной логикой:
- События `round_completed_carried_time` и `carried_time_used` продолжают отправляться
- Серверная логика переноса времени остается рабочей
- Клиентская логика работает независимо от сервера

### Безопасность

Для настольной игры на одном устройстве:
- Игроки не используют читы
- Безопасность не критична
- localStorage защищен от случайного изменения
- Логика проста и понятна

### Исправления

#### Проблема с вычислением времени
**Проблема**: Первоначальная реализация вычисляла перенесенное время на основе разности между временем запуска таймера и текущим клиентским временем, что включало паузы между раундами.

**Решение**: 
- Используется `timerState.remainingTime`, которое уже корректно вычислено с учетом пауз
- Добавлена функция `endRoundByWordsExhausted()` для правильного завершения раунда по исчерпанию слов
- Разделена логика для завершения раунда по истечению времени (перенесенное время = 0) и по исчерпанию слов (перенесенное время = остаток)

#### Ключевые функции
- `calculateCarriedTime()` - использует `timerState.remainingTime` вместо текущего времени
- `endRoundByWordsExhausted()` - правильно завершает раунд при исчерпании слов
- Обновленная обработка события `round_completed` - проверяет состояние таймера

### Исправления логики записи времени (21.09.2025)

#### Проблема с накоплением данных
**Проблема**: Время игроков накапливалось в `playerCarriedTime` на сервере и не очищалось при завершении игры, что приводило к утечке памяти.

**Решение**:
- Добавлена очистка `playerCarriedTime = {}` при завершении игры
- Добавлена очистка `playerCarriedTime = {}` при начале новой игры
- Время НЕ переносится между играми (как требовалось)
- Минимизировано общение с сервером (время хранится на клиенте)

#### Ключевые изменения
- **Функция `startGame()`**: Очистка времени при начале новой игры
- **Функция `startNextRound()`**: Очистка времени при завершении игры
- **Логирование**: Добавлено логирование очистки времени для отладки

### Серверная совместимость
```javascript
// Очистка при завершении игры
gameState.playerCarriedTime = {};
console.log('Перенесенное время очищено при завершении игры');

// Очистка при начале новой игры
gameState.playerCarriedTime = {};
console.log('Перенесенное время очищено при начале новой игры');
```

### Заключение

Реализованная логика полностью соответствует требованиям настольной игры:
- Работает на одном устройстве
- Не требует интернета
- Обеспечивает корректный перенос времени между раундами
- Учитывает только фактическое игровое время
- Проста в использовании и отладке
- **Время НЕ накапливается между играми**
- **Данные очищаются при завершении партии**
- **Минимизировано общение с сервером**

## Нормализация слов

### Алгоритм нормализации
```javascript
function normalizeWord(word) {
  return word
    .toLowerCase()
    .trim()
    .replace(/ё/g, 'е')
    .replace(/[.,!?:;"'()\-–—]/g, '')
    .replace(/\s+/g, ' ')
    .trim();
}
```

### Проверка дубликатов
```javascript
function checkForDuplicates(words) {
  const normalized = new Set();
  const duplicates = [];
  
  for (const word of words) {
    const norm = normalizeWord(word);
    if (normalized.has(norm)) {
      duplicates.push(word);
    } else {
      normalized.add(norm);
    }
  }
  
  return duplicates;
}
```

## Скрипты для работы со словарем

### Скрипт сортировки словаря

**Файл**: `scripts/sort_dictionary.js`

**Назначение**: Единый скрипт для нормализации, дедупликации и сортировки словаря

**Функции**:
- Нормализация слов (верхний регистр, схлопывание пробелов, нормализация тире и апострофов)
- Удаление дубликатов по полной записи (слово+категория+уровень)
- Сортировка по категории, затем по слову (русская колляция)
- Создание бэкапа перед изменениями
- Валидация категорий и уровней
- Подробная статистика

**Использование**:
```bash
node scripts/sort_dictionary.js
```

**Правила сортировки**:
- Формат CSV: слово,категория,уровень
- Сортировка: сначала по категории (алфавит ru, sensitivity=base), затем по слову
- Уровень (обычный/повышенный) не влияет на порядок сортировки
- При записи соблюдается верхний регистр только для колонки «слово»

**Нормализация**:
- Регистр: слова фиксируются В ВЕРХНЕМ РЕГИСТРЕ
- Кириллица: upperCase → trim → нормализация пробелов → нормализация тире (– — − → -) и апострофов (' ` ´ → ')
- «Ё» при сортировке приравнивается к «Е» (колляция ru, sensitivity=base)
- Дедуп-линия: точные дубли записей (слово+категория+уровень после нормализации) удаляются

### Скрипты добавления слов

**Папка**: `scripts/add_ing/`

**Назначение**: Скрипты для добавления слов различных категорий в словарь

**Скрипты**:
- `add_clothing_50.js` - добавление одежды
- `add_fictional_characters_50.js` - добавление вымышленных персонажей
- `add_high_freq_85.js` - добавление высокочастотных слов
- `add_high_freq_more.js` - добавление дополнительных высокочастотных слов
- `add_household_100.js` - добавление предметов быта
- `add_top200_custom.js` - добавление топ-200 кастомных слов
- `add_top200_three_categories.js` - добавление топ-200 слов по трем категориям
- `add_winged_expressions_50.js` - добавление крылатых выражений

### Генерация статистики

**Файл**: `scripts/generate_dictionary_stats.js`

**Назначение**: Генерация статистики словаря в формате Markdown

**Использование**:
```bash
node scripts/generate_dictionary_stats.js
```

**Результат**: Обновляет файл `public/dictionary_statistics.md` с актуальной статистикой по категориям

## Тестирование

### Сценарии для проверки
1. **Завершение игры**: Проверить очистку `playerCarriedTime`
2. **Начало новой игры**: Проверить очистку localStorage и `playerCarriedTime`
3. **Перенос времени**: Проверить корректность переноса между раундами
4. **Утечки памяти**: Проверить отсутствие накопления данных

### Команды для тестирования
```bash
# Запуск сервера
npm start

# Проверка в браузере
# 1. Открыть DevTools → Application → Local Storage
# 2. Начать игру, завершить раунд с остатком времени
# 3. Проверить наличие 'hatGame_carriedTime' в localStorage
# 4. Завершить игру, начать новую
# 5. Проверить очистку localStorage
```

## Мониторинг и отладка

### Логи для отслеживания
- `Перенесенное время очищено при начале новой игры`
- `Перенесенное время очищено при завершении игры`
- `Сохранено перенесенное время Xс для игрока Y`

### Метрики
- Размер `playerCarriedTime` должен быть 0 после завершения игры
- localStorage не должен содержать `hatGame_carriedTime` после начала новой игры

## Пауза: блокировка UI

- Во время паузы все кнопки, кроме «Пауза/Продолжить» и «Завершить игру», переводятся в `disabled`.
- При завершении игры, старте новой игры и при инициализации страницы выполняется разблокировка.
- Точки интеграции: `pauseGame()` → `toggleButtonsDuringPause(true|false)`, а также вызовы разблокировки в `endGame()`, `newGame()`, `startGame()` и обработчике `DOMContentLoaded`.

## Дополнительные метрики игровой сессии

### Отслеживание пропущенных слов

**Структура данных:**
```javascript
sessionStats.wordTracking.passedWords = {
  "слово1": 2,  // пропущено 2 раза
  "слово2": 1   // пропущено 1 раз
}
```

**Логика обновления:**
- При каждом нажатии кнопки "Пропуск" увеличивается счетчик для текущего слова
- Счетчик увеличивается независимо от того, сколько раз слово показывалось разным игрокам
- При завершении сессии находится слово с максимальным счетчиком

### Отслеживание времени показа слов

**Структура данных:**
```javascript
sessionStats.wordTracking.wordDisplayTime = {
  "слово1": 15,  // показано 15 секунд суммарно
  "слово2": 5    // показано 5 секунд суммарно
}
```

**Логика обновления:**
- При показе слова фиксируется `wordShownAt = Date.now()` и `currentWord = word`
- При угадывании/пропуске: `displayTime = (Date.now() - wordShownAt) / 1000` (в секундах)
- При истечении времени хода: `displayTime = timerRemainingAtShow` (время на таймере в момент выдачи слова)
- Суммарное время накапливается для каждого слова
- Время показа = время от момента выдачи слова до момента угадывания/пропуска
- Паузы не влияют на расчет времени (таймер хода на фронте не учитывает паузы)

### Продолжительность раундов и партии

**Структура данных:**
```javascript
sessionStats.duration = {
  roundDurations: { 0: 180, 1: 165, 2: 195 }, // в секундах
  totalGameDuration: 540 // в секундах
}
```

**Логика обновления:**
- При завершении раунда: `roundDuration = sum(activeTimePerTurn)` в секундах
- При завершении партии: `totalDuration = sum(roundDurations)` в секундах
- Используется только активное время (исключая паузы)
- Продолжительность раунда = сумма времени всех ходов в раунде

### Интеграция с StatsService

**Инициализация:**
- Все структуры данных инициализируются при запуске сессии в методе `resetSession()`
- Данные автоматически сбрасываются при старте каждой новой игровой сессии

**Интеграция с существующими методами:**
- Расширение `onWordGuessed(playerId, round)` - добавление обновления времени показа слова
- Расширение `onWordPassed(playerId, round)` - добавление обновления счетчика пропусков
- Новый метод `onWordShown(word)` - фиксация времени показа слова
- Новый метод `onRoundEnded(round)` - фиксация продолжительности раунда
- Новый метод `calculateSessionFacts()` - расчет фактов сессии

**Хранение текущего слова:**
- `sessionStats._currentWord` - текущее показываемое слово
- `sessionStats._wordShownAt` - время показа текущего слова

**Обработка истечения времени хода:**
- Определяется через событие `end_turn` в существующей логике
- При истечении времени используется `timerRemainingAtShow`

**События в event log:**
- `WORD_SHOWN` - показ слова с временной меткой
- `WORD_DISPLAY_TIME_UPDATED` - обновление времени показа
- `ROUND_DURATION_RECORDED` - фиксация продолжительности раунда

**Валидация данных:**
- Время на таймере не может быть отрицательным
- Слова попадают в структуры только из сформированного словаря
- Добавлена проверка корректности данных при обновлении метрик

**Тестирование:**
- Подробные unit-тесты для всех новых методов
- Интеграционные тесты для проверки корректности сбора метрик
- Тесты для обработки граничных случаев (истечение времени, паузы)