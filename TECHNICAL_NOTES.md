# Технические заметки - Hat Web

## Архитектура системы

### WebSocket события
```javascript
// Клиент → Сервер
'start_game'     // Начать игру
'next_word'      // Следующее слово
'word_guessed'   // Слово угадано
'word_passed'    // Пас
'pause_game'     // Пауза
'resume_game'    // Продолжить

// Сервер → Клиент
'game_state'     // Текущее состояние игры
'error'          // Ошибка
'game_ended'     // Игра завершена
```

#### Порядок событий при завершении раунда

Для корректного учета последнего угаданного слова сервер всегда отправляет события в таком порядке:
1) `game_state` — с уже обновленными `scores`, `teamStatsByRound`, `usedWords`;
2) `round_completed` — триггер перехода клиентского UI: после раунда 1 сразу показывается экран правил 2‑го раунда; после раунда 2 — экран правил 3‑го.

Это касается как автоматического завершения (последнее слово), так и ручного `end_round`.
Реализация: `src/infrastructure/GameService.js` в методах `handleWordGuessed` и `handleEndRound`.

### Структура gameState
```javascript
{
  gameId: string,
  players: Array<{id: string, name: string, teamId: string}>,
  teams: Array<{id: string, name: string, playerIds: string[]}>,
  currentRound: 0 | 1 | 2,
  currentPlayer: {id: string, name: string, teamId: string},
  currentWord: string | null,
  availableWords: string[],
  usedWords: string[],
  teamStatsByRound: {
    0: {[teamId: string]: number},
    1: {[teamId: string]: number}, 
    2: {[teamId: string]: number}
  },
  playerStats: {
    [playerId: string]: {
      guessed: number,
      passed: number,
      totalScore: number
    }
  },
  playerCarriedTime: {[playerId: string]: number} // секунды; очищается при завершении игры
}
```

## Реализация переноса времени на клиенте

### Обзор

Реализована логика переноса остатка времени между раундами игры исключительно на стороне клиента, без зависимости от сервера. Это обеспечивает полную автономность игры и минимизирует зависимость от интернета.

### Архитектура

#### Хранение данных
- **localStorage**: Используется для сохранения перенесенного времени между раундами
- **Ключ**: `hatGame_carriedTime`
- **Формат**: Строковое представление числа секунд

#### Функции

##### `saveCarriedTime(timeLeft)`
- Сохраняет перенесенное время в localStorage
- Если `timeLeft > 0` - сохраняет значение
- Если `timeLeft <= 0` - удаляет ключ из localStorage
- **Параметры**: `timeLeft` (number) - количество секунд для переноса
- **Возвращает**: void

##### `loadCarriedTime()`
- Загружает перенесенное время из localStorage
- Возвращает 0, если время не сохранено
- **Параметры**: нет
- **Возвращает**: number - количество секунд

##### `clearCarriedTime()`
- Удаляет перенесенное время из localStorage
- Используется при начале новой игры или после использования времени
- **Параметры**: нет
- **Возвращает**: void

### Интеграция с игровой логикой

#### Завершение раунда
```javascript
// При завершении раунда
const carriedTime = Math.ceil(timerState.remainingTime / 1000);
saveCarriedTime(carriedTime);
```

#### Начало нового раунда
```javascript
// При запуске таймера
const loadedCarriedTime = loadCarriedTime();
// Минимум 5 секунд при старте 2-го и 3-го раундов применяется на стороне сервера в Game.startNextRound()
// На клиенте значения всегда в секундах
const actualDuration = loadedCarriedTime > 0 ? loadedCarriedTime : durationSeconds;

if (loadedCarriedTime > 0) {
    clearCarriedTime(); // Очищаем после использования
}
```

#### Начало новой игры
```javascript
// При старте новой игры
clearCarriedTime(); // Очищаем все перенесенное время
```

### Логика работы

1. **Завершение раунда по истечению времени**: 
   - Перенесенное время = 0 (время истекло)
   - Время сохраняется в localStorage
   - Отправляется событие на сервер (для совместимости)

2. **Завершение раунда по исчерпанию слов**:
   - Вычисляется остаток времени на основе `timerState.remainingTime`
   - Время сохраняется в localStorage
   - Отправляется событие на сервер (для совместимости)

3. **Начало нового раунда**:
   - Загружается перенесенное время из localStorage
   - Если есть перенесенное время - используется только оно
   - Если нет - используется стандартное время раунда
   - Перенесенное время очищается после использования

4. **Начало новой игры**:
   - Все перенесенное время очищается

### Преимущества

- ✅ **Автономность**: Игра работает без интернета
- ✅ **Простота**: Нет серверной инфраструктуры для времени
- ✅ **Надежность**: Нет зависимости от сетевого соединения
- ✅ **Быстродействие**: Мгновенные переходы между раундами
- ✅ **Совместимость**: Сохранена совместимость с серверной логикой

### Тестирование

Создан тестовый файл `test_time_carry.html` для проверки:
- Сохранения времени
- Загрузки времени
- Полного цикла переноса
- Информации о localStorage

### Совместимость

Реализация сохраняет совместимость с существующей серверной логикой:
- События `round_completed_carried_time` и `carried_time_used` продолжают отправляться
- Серверная логика переноса времени остается рабочей
- Клиентская логика работает независимо от сервера

### Безопасность

Для настольной игры на одном устройстве:
- Игроки не используют читы
- Безопасность не критична
- localStorage защищен от случайного изменения
- Логика проста и понятна

### Исправления

#### Проблема с вычислением времени
**Проблема**: Первоначальная реализация вычисляла перенесенное время на основе разности между временем запуска таймера и текущим клиентским временем, что включало паузы между раундами.

**Решение**: 
- Используется `timerState.remainingTime`, которое уже корректно вычислено с учетом пауз
- Добавлена функция `endRoundByWordsExhausted()` для правильного завершения раунда по исчерпанию слов
- Разделена логика для завершения раунда по истечению времени (перенесенное время = 0) и по исчерпанию слов (перенесенное время = остаток)

#### Ключевые функции
- `calculateCarriedTime()` - использует `timerState.remainingTime` вместо текущего времени
- `endRoundByWordsExhausted()` - правильно завершает раунд при исчерпании слов
- Обновленная обработка события `round_completed` - проверяет состояние таймера

### Исправления логики записи времени (21.09.2025)

#### Проблема с накоплением данных
**Проблема**: Время игроков накапливалось в `playerCarriedTime` на сервере и не очищалось при завершении игры, что приводило к утечке памяти.

**Решение**:
- Добавлена очистка `playerCarriedTime = {}` при завершении игры
- Добавлена очистка `playerCarriedTime = {}` при начале новой игры
- Время НЕ переносится между играми (как требовалось)
- Минимизировано общение с сервером (время хранится на клиенте)

#### Ключевые изменения
- **Функция `startGame()`**: Очистка времени при начале новой игры
- **Функция `startNextRound()`**: Очистка времени при завершении игры
- **Логирование**: Добавлено логирование очистки времени для отладки

### Серверная совместимость
```javascript
// Очистка при завершении игры
gameState.playerCarriedTime = {};
console.log('Перенесенное время очищено при завершении игры');

// Очистка при начале новой игры
gameState.playerCarriedTime = {};
console.log('Перенесенное время очищено при начале новой игры');
```

### Заключение

Реализованная логика полностью соответствует требованиям настольной игры:
- Работает на одном устройстве
- Не требует интернета
- Обеспечивает корректный перенос времени между раундами
- Учитывает только фактическое игровое время
- Проста в использовании и отладке
- **Время НЕ накапливается между играми**
- **Данные очищаются при завершении партии**
- **Минимизировано общение с сервером**

## Нормализация слов

### Алгоритм нормализации
```javascript
function normalizeWord(word) {
  return word
    .toLowerCase()
    .trim()
    .replace(/ё/g, 'е')
    .replace(/[.,!?:;"'()\-–—]/g, '')
    .replace(/\s+/g, ' ')
    .trim();
}
```

### Проверка дубликатов
```javascript
function checkForDuplicates(words) {
  const normalized = new Set();
  const duplicates = [];
  
  for (const word of words) {
    const norm = normalizeWord(word);
    if (normalized.has(norm)) {
      duplicates.push(word);
    } else {
      normalized.add(norm);
    }
  }
  
  return duplicates;
}
```

## Скрипты для работы со словарем

### Скрипт сортировки словаря

**Файл**: `scripts/sort_dictionary.js`

**Назначение**: Единый скрипт для нормализации, дедупликации и сортировки словаря

**Функции**:
- Нормализация слов (верхний регистр, схлопывание пробелов, нормализация тире и апострофов)
- Удаление дубликатов по полной записи (слово+категория+уровень)
- Сортировка по категории, затем по слову (русская колляция)
- Создание бэкапа перед изменениями
- Валидация категорий и уровней
- Подробная статистика

**Использование**:
```bash
node scripts/sort_dictionary.js
```

**Правила сортировки**:
- Формат CSV: слово,категория,уровень
- Сортировка: сначала по категории (алфавит ru, sensitivity=base), затем по слову
- Уровень (обычный/повышенный) не влияет на порядок сортировки
- При записи соблюдается верхний регистр только для колонки «слово»

**Нормализация**:
- Регистр: слова фиксируются В ВЕРХНЕМ РЕГИСТРЕ
- Кириллица: upperCase → trim → нормализация пробелов → нормализация тире (– — − → -) и апострофов (' ` ´ → ')
- «Ё» при сортировке приравнивается к «Е» (колляция ru, sensitivity=base)
- Дедуп-линия: точные дубли записей (слово+категория+уровень после нормализации) удаляются

### Скрипты добавления слов

**Папка**: `scripts/add_ing/`

**Назначение**: Скрипты для добавления слов различных категорий в словарь

**Скрипты**:
- `add_clothing_50.js` - добавление одежды
- `add_fictional_characters_50.js` - добавление вымышленных персонажей
- `add_high_freq_85.js` - добавление высокочастотных слов
- `add_high_freq_more.js` - добавление дополнительных высокочастотных слов
- `add_household_100.js` - добавление предметов быта
- `add_top200_custom.js` - добавление топ-200 кастомных слов
- `add_top200_three_categories.js` - добавление топ-200 слов по трем категориям
- `add_winged_expressions_50.js` - добавление крылатых выражений

### Генерация статистики

**Файл**: `scripts/generate_dictionary_stats.js`

**Назначение**: Генерация статистики словаря в формате Markdown

**Использование**:
```bash
node scripts/generate_dictionary_stats.js
```

**Результат**: Обновляет файл `public/dictionary_statistics.md` с актуальной статистикой по категориям

## Тестирование

### Сценарии для проверки
1. **Завершение игры**: Проверить очистку `playerCarriedTime`
2. **Начало новой игры**: Проверить очистку localStorage и `playerCarriedTime`
3. **Перенос времени**: Проверить корректность переноса между раундами
4. **Утечки памяти**: Проверить отсутствие накопления данных

### Команды для тестирования
```bash
# Запуск сервера
npm start

# Проверка в браузере
# 1. Открыть DevTools → Application → Local Storage
# 2. Начать игру, завершить раунд с остатком времени
# 3. Проверить наличие 'hatGame_carriedTime' в localStorage
# 4. Завершить игру, начать новую
# 5. Проверить очистку localStorage
```

## Мониторинг и отладка

### Логи для отслеживания
- `Перенесенное время очищено при начале новой игры`
- `Перенесенное время очищено при завершении игры`
- `Сохранено перенесенное время Xс для игрока Y`

### Метрики
- Размер `playerCarriedTime` должен быть 0 после завершения игры
- localStorage не должен содержать `hatGame_carriedTime` после начала новой игры

## Пауза: блокировка UI

- Во время паузы все кнопки, кроме «Пауза/Продолжить» и «Завершить игру», переводятся в `disabled`.
- При завершении игры, старте новой игры и при инициализации страницы выполняется разблокировка.
- Точки интеграции: `pauseGame()` → `toggleButtonsDuringPause(true|false)`, а также вызовы разблокировки в `endGame()`, `newGame()`, `startGame()` и обработчике `DOMContentLoaded`.
