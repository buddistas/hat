# Технические заметки - Hat Web

## Архитектура системы

### WebSocket события
```javascript
// Клиент → Сервер
'start_game'     // Начать игру
'next_word'      // Следующее слово
'word_guessed'   // Слово угадано
'word_passed'    // Пас
'pause_game'     // Пауза
'resume_game'    // Продолжить

// Сервер → Клиент
'game_state'     // Текущее состояние игры
'error'          // Ошибка
'game_ended'     // Игра завершена
```

#### Порядок событий при завершении раунда

Для корректного учета последнего угаданного слова сервер всегда отправляет события в таком порядке:
1) `game_state` — с уже обновленными `scores`, `teamStatsByRound`, `usedWords`;
2) `round_completed` — триггер показа экрана результатов раунда на клиенте.

Это касается как автоматического завершения (последнее слово), так и ручного `end_round`.
Реализация: `src/infrastructure/GameService.js` в методах `handleWordGuessed` и `handleEndRound`.

### Структура gameState
```javascript
{
  gameId: string,
  players: Array<{id: string, name: string, teamId: string}>,
  teams: Array<{id: string, name: string, playerIds: string[]}>,
  currentRound: 0 | 1 | 2,
  currentPlayer: {id: string, name: string, teamId: string},
  currentWord: string | null,
  availableWords: string[],
  usedWords: string[],
  teamStatsByRound: {
    0: {[teamId: string]: number},
    1: {[teamId: string]: number}, 
    2: {[teamId: string]: number}
  },
  playerStats: {
    [playerId: string]: {
      guessed: number,
      passed: number,
      totalScore: number
    }
  },
  playerCarriedTime: {[playerId: string]: number} // Очищается при завершении игры
}
```

## Реализация переноса времени на клиенте

### Обзор

Реализована логика переноса остатка времени между раундами игры исключительно на стороне клиента, без зависимости от сервера. Это обеспечивает полную автономность игры и минимизирует зависимость от интернета.

### Архитектура

#### Хранение данных
- **localStorage**: Используется для сохранения перенесенного времени между раундами
- **Ключ**: `hatGame_carriedTime`
- **Формат**: Строковое представление числа секунд

#### Функции

##### `saveCarriedTime(timeLeft)`
- Сохраняет перенесенное время в localStorage
- Если `timeLeft > 0` - сохраняет значение
- Если `timeLeft <= 0` - удаляет ключ из localStorage
- **Параметры**: `timeLeft` (number) - количество секунд для переноса
- **Возвращает**: void

##### `loadCarriedTime()`
- Загружает перенесенное время из localStorage
- Возвращает 0, если время не сохранено
- **Параметры**: нет
- **Возвращает**: number - количество секунд

##### `clearCarriedTime()`
- Удаляет перенесенное время из localStorage
- Используется при начале новой игры или после использования времени
- **Параметры**: нет
- **Возвращает**: void

### Интеграция с игровой логикой

#### Завершение раунда
```javascript
// При завершении раунда
const carriedTime = Math.ceil(timerState.remainingTime / 1000);
saveCarriedTime(carriedTime);
```

#### Начало нового раунда
```javascript
// При запуске таймера
const loadedCarriedTime = loadCarriedTime();
const actualDuration = loadedCarriedTime > 0 ? loadedCarriedTime : durationSeconds;

if (loadedCarriedTime > 0) {
    clearCarriedTime(); // Очищаем после использования
}
```

#### Начало новой игры
```javascript
// При старте новой игры
clearCarriedTime(); // Очищаем все перенесенное время
```

### Логика работы

1. **Завершение раунда по истечению времени**: 
   - Перенесенное время = 0 (время истекло)
   - Время сохраняется в localStorage
   - Отправляется событие на сервер (для совместимости)

2. **Завершение раунда по исчерпанию слов**:
   - Вычисляется остаток времени на основе `timerState.remainingTime`
   - Время сохраняется в localStorage
   - Отправляется событие на сервер (для совместимости)

3. **Начало нового раунда**:
   - Загружается перенесенное время из localStorage
   - Если есть перенесенное время - используется только оно
   - Если нет - используется стандартное время раунда
   - Перенесенное время очищается после использования

4. **Начало новой игры**:
   - Все перенесенное время очищается

### Преимущества

- ✅ **Автономность**: Игра работает без интернета
- ✅ **Простота**: Нет серверной инфраструктуры для времени
- ✅ **Надежность**: Нет зависимости от сетевого соединения
- ✅ **Быстродействие**: Мгновенные переходы между раундами
- ✅ **Совместимость**: Сохранена совместимость с серверной логикой

### Тестирование

Создан тестовый файл `test_time_carry.html` для проверки:
- Сохранения времени
- Загрузки времени
- Полного цикла переноса
- Информации о localStorage

### Совместимость

Реализация сохраняет совместимость с существующей серверной логикой:
- События `round_completed_carried_time` и `carried_time_used` продолжают отправляться
- Серверная логика переноса времени остается рабочей
- Клиентская логика работает независимо от сервера

### Безопасность

Для настольной игры на одном устройстве:
- Игроки не используют читы
- Безопасность не критична
- localStorage защищен от случайного изменения
- Логика проста и понятна

### Исправления

#### Проблема с вычислением времени
**Проблема**: Первоначальная реализация вычисляла перенесенное время на основе разности между временем запуска таймера и текущим клиентским временем, что включало паузы между раундами.

**Решение**: 
- Используется `timerState.remainingTime`, которое уже корректно вычислено с учетом пауз
- Добавлена функция `endRoundByWordsExhausted()` для правильного завершения раунда по исчерпанию слов
- Разделена логика для завершения раунда по истечению времени (перенесенное время = 0) и по исчерпанию слов (перенесенное время = остаток)

#### Ключевые функции
- `calculateCarriedTime()` - использует `timerState.remainingTime` вместо текущего времени
- `endRoundByWordsExhausted()` - правильно завершает раунд при исчерпании слов
- Обновленная обработка события `round_completed` - проверяет состояние таймера

### Исправления логики записи времени (21.09.2025)

#### Проблема с накоплением данных
**Проблема**: Время игроков накапливалось в `playerCarriedTime` на сервере и не очищалось при завершении игры, что приводило к утечке памяти.

**Решение**:
- Добавлена очистка `playerCarriedTime = {}` при завершении игры
- Добавлена очистка `playerCarriedTime = {}` при начале новой игры
- Время НЕ переносится между играми (как требовалось)
- Минимизировано общение с сервером (время хранится на клиенте)

#### Ключевые изменения
- **Функция `startGame()`**: Очистка времени при начале новой игры
- **Функция `startNextRound()`**: Очистка времени при завершении игры
- **Логирование**: Добавлено логирование очистки времени для отладки

### Серверная совместимость
```javascript
// Очистка при завершении игры
gameState.playerCarriedTime = {};
console.log('Перенесенное время очищено при завершении игры');

// Очистка при начале новой игры
gameState.playerCarriedTime = {};
console.log('Перенесенное время очищено при начале новой игры');
```

### Заключение

Реализованная логика полностью соответствует требованиям настольной игры:
- Работает на одном устройстве
- Не требует интернета
- Обеспечивает корректный перенос времени между раундами
- Учитывает только фактическое игровое время
- Проста в использовании и отладке
- **Время НЕ накапливается между играми**
- **Данные очищаются при завершении партии**
- **Минимизировано общение с сервером**

## Нормализация слов

### Алгоритм нормализации
```javascript
function normalizeWord(word) {
  return word
    .toLowerCase()
    .trim()
    .replace(/ё/g, 'е')
    .replace(/[.,!?:;"'()\-–—]/g, '')
    .replace(/\s+/g, ' ')
    .trim();
}
```

### Проверка дубликатов
```javascript
function checkForDuplicates(words) {
  const normalized = new Set();
  const duplicates = [];
  
  for (const word of words) {
    const norm = normalizeWord(word);
    if (normalized.has(norm)) {
      duplicates.push(word);
    } else {
      normalized.add(norm);
    }
  }
  
  return duplicates;
}
```

## Тестирование

### Сценарии для проверки
1. **Завершение игры**: Проверить очистку `playerCarriedTime`
2. **Начало новой игры**: Проверить очистку localStorage и `playerCarriedTime`
3. **Перенос времени**: Проверить корректность переноса между раундами
4. **Утечки памяти**: Проверить отсутствие накопления данных

### Команды для тестирования
```bash
# Запуск сервера
npm start

# Проверка в браузере
# 1. Открыть DevTools → Application → Local Storage
# 2. Начать игру, завершить раунд с остатком времени
# 3. Проверить наличие 'hatGame_carriedTime' в localStorage
# 4. Завершить игру, начать новую
# 5. Проверить очистку localStorage
```

## Мониторинг и отладка

### Логи для отслеживания
- `Перенесенное время очищено при начале новой игры`
- `Перенесенное время очищено при завершении игры`
- `Сохранено перенесенное время Xс для игрока Y`

### Метрики
- Размер `playerCarriedTime` должен быть 0 после завершения игры
- localStorage не должен содержать `hatGame_carriedTime` после начала новой игры
