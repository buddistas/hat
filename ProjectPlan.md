# Hat Web — План проекта (RU)

## Оглавление
- [1. Цели и ограничения](#1-цели-и-ограничения)
- [2. Технологический стек](#2-технологический-стек)
- [3. Основные поставки (MVP)](#3-основные-поставки-mvp)
- [4. Этапы и сроки](#4-этапы-и-сроки)
- [5. Команды](#5-команды)
- [6. Структура приложения](#6-структура-приложения)
- [7. Реализация правил игры](#7-реализация-правил-игры)
- [8. Структура данных](#8-структура-данных-текущая-реализация)
- [9. Нормализация слов](#9-нормализация-слов)
- [10. Состояния игры](#10-состояния-игры)
- [11. Таймер и перенос времени](#11-таймер-и-перенос-времени)
- [12. Распределение и порядок слов](#12-распределение-и-порядок-слов)
- [13. Экраны и UX‑особенности](#13-экраны-и-uxособенности)
- [14. Аналитика и статистика](#14-аналитика-и-статистика)
- [15. План тестирования](#15-план-тестирования)
- [16. Производительность и доступность](#16-производительность-и-доступность)
- [17. Критерии приёмки (MVP)](#17-критерии-приёмки-mvp)
- [18. Текущий статус проекта](#18-текущий-статус-проекта)
 - [19. Принципы пополнения словаря](#19-принципы-пополнения-словаря)
 - [20. Идентификация игроков и статистика (локально)](#20-идентификация-игроков-и-статистика-локально)

---

## 1. Цели и ограничения
- **Тип игры**: Настольная игра на одном устройстве, передаваемая от игрока к игроку (однопользовательское приложение)
- **Синхронизация**: Не требуется, игра работает на одном устройстве без серверной зависимости
- **Безопасность**: Игроки не используют читы, безопасность не критична
- **Сетевые условия**: Не принципиальны, цель - минимизировать зависимость от интернета
- **Архитектура**: Клиентская реализация логики переноса времени для автономности
- Один девайс, режим pass-and-play; 4–20 игроков суммарно.
- Три раунда: 1) свободное объяснение, 2) жесты/мимика, 3) одно слово.
- Ход 60 секунд; PASS = −1 очко; угаданное = +1 очко.
- Раунд заканчивается, когда «шляпа» пуста; игра завершается, когда пуста шляпа в раунде 3.
- Перенос времени между раундами (ceil до секунды); следующий раунд начинает тот же игрок, и первая попытка использует только перенесённые секунды (без базовых 60s).
- Базовый словарь RU; брендовые названия отображаются в оригинале (латиницей), нормализация особым путём.
- Пользовательские слова — отдельная категория внутри базового RU-пака; глобальная дедупликация. Каждое слово (или фраза) может принадлежать только одной категории.
- Mobile-first, портретная ориентация, вибрация + звук, офлайн‑режим с восстановлением.
- Звук обязателен для игрового опыта; приложение не предоставляет «тихий режим».
- На экране хода доступна пауза/возобновление для ведущего игрока.
- Ответы подтверждаются вручную: текущий игрок нажимает «Верно», приложение не анализирует корректность ответа.
- Глобальная статистика и Telegram‑аутентификация — на серверной фазе.

## 2. Технологический стек (MVP - упрощенный)
- Frontend: Vanilla HTML/CSS/JavaScript с WebSocket подключением для реактивности
- Backend: Node.js с WebSocket сервером для раздачи статической страницы и обработки JSON событий
- Таймер: Полностью клиентский с `performance.now()` + `requestAnimationFrame`
- Данные: Слова в отдельном файле через запятую (один файл, все слова в одной строке)
- UI: Интерфейс аналогичный приложению Hat Up (http://apps.apple.com/ru/app/hat-up/id1472656524)
- Архитектура: Одна комната, многопользовательская игра на одном устройстве (pass-and-play)

## 3. Основные поставки (MVP)
- MVP: полный 3‑раундный цикл, таймер с переносом, подсчёт очков/штрафы, базовый словарь из файла, итоги с «интересными фактами», вибро/звук
- WebSocket сервер: раздача статической страницы, обработка JSON событий между клиентом и сервером
- Интерфейс: повторение UI приложения Hat Up для знакомого пользовательского опыта
- Архитектура: pass-and-play на одном устройстве, одна комната для всех игроков

## 4. Этапы и сроки
- M1: Node.js WebSocket сервер + статическая HTML страница с базовым UI. (1 день)
- M2: Игровая логика: 3 раунда, таймер с переносом, подсчёт очков, базовый словарь из файла. (1 день)
- M3: WebSocket события: JSON коммуникация между клиентом и сервером. (1 день)
- M4: UI аналогичный Hat Up: экраны настройки, игры, результатов. (1 день)
- M5: Звук, вибрация, пауза/возобновление, финальная полировка. (1 день)

## 5. Команды
- Количество команд: 2–4.
- Размер команды: от 2 до 5 игроков.
- Балансировка: максимальная разница в численности между командами — 1 игрок.
- Распределение игроков:
  - Кнопка авто‑распределения по командам с возможностью повторного реролла.
  - Возможность ручного заполнения/редактирования составов.

## 6. Структура приложения
```
hat_web/
  server.js          # Node.js WebSocket сервер
  package.json       # Зависимости Node.js
  public/
    index.html       # Статическая страница с встроенным CSS/JS
    words.csv        # Словарь через запятую
```

## 7. Реализация правил игры
- Общий пул слов на всю игру; каждый раунд переиспользует слова, пока все не будут угаданы.
- `PASS` немедленно снижает очки команды на 1 (−1) и фиксируется в логе событий.
- Перенос времени (carry‑over):
  - Если раунд исчерпан во время активного хода, следующий раунд начинает тот же игрок с ceil(remainingSeconds).
  - Первая попытка следующего раунда использует только перенесённые секунды (без базовых 60s).
  - Все последующие попытки в раунде — стандартные 60s.
  - Если раунд завершился ровно в момент истечения хода (time up), перенос не применяется.
  - **Время НЕ переносится между играми** - очищается при завершении партии.
  - **Данные очищаются при завершении игры** - предотвращает накопление и утечки памяти.
- Очки могут уходить в отрицательные значения; нижних границ нет.

### 7.1. Логика очередности ходов
- **Инициализация очереди**: При старте игры формируется фиксированная очередь ходов:
  - Случайный порядок команд (перемешивание массива команд)
  - Случайный порядок игроков внутри каждой команды
  - Структура данных `turnOrder`:
    ```js
    turnOrder: {
      teams: [], // Порядок команд (случайный)
      playersByTeam: {}, // Порядок игроков внутри каждой команды (случайный)
      currentTeamIndex: 0, // Индекс текущей команды в очереди
      currentPlayerIndex: 0 // Индекс текущего игрока в команде
    }
    ```

- **Алгоритм переключения ходов**:
  1. Ход переходит к следующей команде в очереди (`currentTeamIndex++`)
  2. Если достигнут конец списка команд (`currentTeamIndex === 0`), переходим к следующему игроку (`currentPlayerIndex++`)
  3. Если индекс игрока превышает количество игроков в команде, сбрасываем на 0
  4. Выбираем игрока: `teams[currentTeamIndex].playersByTeam[currentPlayerIndex]`

- **Перемешивание слов при смене игрока**:
  - При каждом переходе хода к новому игроку слова в пуле перемешиваются заново
  - Используется алгоритм Fisher-Yates для равномерного распределения
  - Пропущенные слова остаются в пуле и могут достаться любому игроку

- **Экран представления игрока**:
  - Показывается перед каждым ходом игрока, включая первый
  - Отображает имя текущего игрока и его команду
  - Имеет красивую анимацию появления с эффектом свечения
  - Позволяет игрокам подготовиться к своему ходу
  - Переходит к игровому экрану по нажатию кнопки "Начать"

- **Экран передачи хода**:
  - Показывается между ходами игроков для плавного перехода
  - Отображает имя следующего игрока и его команду
  - Позволяет игрокам подготовиться к своему ходу
  - Автоматически переходит к экрану представления игрока по нажатию "Старт"

- **Правило повторной выдачи PASS-слов**:
  - Пропущенные слова перемещаются в конец очереди `availableWords`
  - Могут достаться тому же игроку только если в пуле не осталось других слов
  - Статистика пропусков ведется отдельно для аналитики

## 8. Структура данных (текущая реализация)

### gameState (сервер)
```javascript
{
  gameId: string,
  players: Array<{id: string, name: string, teamId: string}>,
  teams: Array<{id: string, name: string, playerIds: string[]}>,
  currentRound: 0 | 1 | 2,
  currentPlayer: {id: string, name: string, teamId: string},
  currentWord: string | null,
  availableWords: string[],
  usedWords: string[],
  teamStatsByRound: {
    0: {[teamId: string]: number},
    1: {[teamId: string]: number}, 
    2: {[teamId: string]: number}
  },
  playerStats: {
    [playerId: string]: {
      guessed: number,
      passed: number,
      totalScore: number
    }
  },
  playerCarriedTime: {[playerId: string]: number} // Очищается при завершении игры
}
```

## 9. Нормализация слов
- Регистр: в хранимом CSV все СЛОВА (первая колонка) фиксируются В ВЕРХНЕМ РЕГИСТРЕ; категории и уровень сохраняют исходный регистр/написание.
- Кириллица: upperCase → trim → нормализация пробелов (схлопывание) → нормализация тире (– — − → `-`) и апострофов (’ ` ´ → `'`) → trim. «Ё» при сортировке приравнивается к «Е» (колляция ru, sensitivity=base).
- Бренды (латиница): переводятся в верхний регистр, спецсимволы не изменяются, кроме нормализации пробелов/апострофов/тире.
- Пользовательские слова: дефис/тире и апостроф разрешены; эмодзи запрещены.
- В исходном базовом словаре разрешены любые символы (кроме эмодзи в пользовательском вводе).
- Дедуп-линия: точные дубли записей (слово+категория+уровень после нормализации) удаляются.

## 10. Состояния игры
- Состояния: `lobby` → `setup` → `preround(r)` → `handoff` → `turnActive` → `turnEnd` → `roundReview` → `roundEnd` → `preround(r+1)` → … → `gameSummary`
- События: `GAME_CREATED`, `TEAMS_CONFIGURED`, `START_ROUND`, `START_TURN`, `PAUSE`, `RESUME`, `GUESS_OK`, `PASS`, `TIMER_TICK`, `TIMER_EXPIRED`, `END_TURN`, `ROUND_DEPLETED`, `CARRY_TIME`, `START_NEXT_ROUND`, `END_GAME`

## 11. Таймер и перенос времени
- **Архитектура**: Полностью клиентский таймер с использованием `performance.now()` + `requestAnimationFrame`.
- **Хранение времени**: Использование `localStorage` для сохранения перенесенного времени между раундами
- **Корректировка**: Автоматическая корректировка через событие `visibilitychange` при возвращении в фокус.
- **Формулы**:
  - `remainingTime = max(0, duration - (now - startTime))`
  - `carry = ceil(remainingTime / 1000)` - перенос времени между раундами
- **Особенности**:
  - Точность до миллисекунд
  - Устойчивость к проблемам фоновых вкладок
  - Поддержка паузы/возобновления
  - Перенос времени только на первую попытку следующего раунда
  - **Автономность**: Полная независимость от сервера для логики времени
  - **Надежность**: Работает без интернет-соединения
  - **Очистка данных**: Время НЕ переносится между играми, очищается при завершении партии

## 12. Распределение и порядок слов
- Порядок слов в каждом раунде — случайный.
- Равномерность выдачи между игроками не гарантируется.
- Пропущенное слово может вновь достаться тому же игроку только если в шляпе не осталось других слов.
 - Подтверждение угадывания выполняется вручную: ведущий нажимает «Верно» при слышимом правильном ответе.

### 12.1. Порядок и сортировка словаря (CSV)
- Формат CSV: `слово,категория,уровень` (без заголовка или с заголовком — опционально).
- Сортировка: сначала по категории (алфавит `ru`, `sensitivity=base`), затем по слову (алфавит `ru`, `sensitivity=base`).
- Уровень (`обычный`/`повышенный`) не влияет на порядок сортировки.
- При записи соблюдается верхний регистр только для колонки «слово».

## 13. Экраны и UX‑особенности
- Start/Lobby, Setup (имена 1–24 символа; 4–20 игроков; имя обязательно; опционально `@username`), Rules, PlayerIntro (экран представления игрока с анимацией), Handoff, Turn (крупное слово, таймер, кнопки `Угадано`/`Пас`), Review, Results, Dictionary, Settings.
- Раунд 2 без текстовых подсказок (только жесты/мимика).
- Вибро: старт(60ms), T−5s([30,40,30]), guessed/pass(25ms), конец(120ms).
- Звук: обязателен. Короткий стартовый сигнал, одиночный на `T−5s`, длинный на окончание, клики кнопок (прелоад). Экран первичного «разблокирования аудио» по первому тапу. Отдельного «тихого режима» нет.
- Учитывать системные настройки по возможности, но отдельного «тихого режима» нет.
- На экране хода — кнопка `Пауза/Возобновить`; при паузе блокируются все кнопки, кроме паузы и завершения игры; блокировка снимается при завершении/инициализации игры.
- **Счетчик слов**: Отображение "Еще слов - X" на экране хода с динамическим обновлением и цветовой индикацией (красный ≤10, оранжевый 11-25, желтый >25 слов).

## 14. Аналитика и статистика
- **Статистика команд**: очки по раундам (teamStatsByRound), общий счет, определение победителя
- **Личная статистика игроков**: количество угаданных слов, пропущенных слов, общие очки
- **Отображение**: два переключаемых экрана с таблицами статистики в финальных результатах
- **Цветовая индикация**: зеленый (положительные очки), красный (отрицательные), серый (ноль)

## 15. План тестирования
- Unit: клиентский таймер, подсчёт с −1 за PASS, переиспользование пула между раундами, нормализация/дедуп
- Component: Turn (моки таймера/вибро/звука), Review, Dictionary (валидация/ошибки)
- E2E: полный 3‑раундный матч с переносом, восстановление после перезагрузки, сценарий Пауза/Возобновить

## 16. Производительность и доступность
- Мемоизация, минимум лишних перерисовок, предзагрузка аудио
- Высокая контрастность, крупные тач‑таргеты, ARIA по необходимости
- Портретная ориентация; мягкие подсказки при повороте устройства

## 17. Критерии приёмки (MVP)
- Полный 3‑раундный цикл с переносом времени (ceil) и штрафами.
- Корректная очистка времени при завершении игры (предотвращение утечек памяти).
- 2–4 команды; 2–5 игроков в команде; макс. разница между командами — 1 игрок.
- Авто‑распределение с рероллом и ручное редактирование составов.
- PASS даёт −1 очко; возможны отрицательные очки.
- Пользовательские слова — отдельная категория; дедуп работает для кириллицы/латиницы; эмодзи запрещены.
- Порядок слов — случайный; правило повторной выдачи PASS‑слова соблюдается.
- Звук обязателен; вибро и звук работают в критических точках; экран разблокировки аудио; отдельного «тихого режима» нет.
- RU‑локализация; офлайн‑режим; восстановление сессии.
- На экране хода доступна пауза/возобновление; во время паузы действия заблокированы, события логируются.
- Подтверждение угадывания выполняется вручную кнопкой «Верно» текущего игрока; автоматическая проверка отсутствует.
- Тесты: ключевые unit/component + минимум 3 E2E‑сценария (полный матч, восстановление, пауза/мьют/распределение).

## 18. Текущий статус проекта

### Реализованные функции (MVP)
- ✅ Полный 3-раундный цикл игры
- ✅ Таймер с переносом времени между раундами
- ✅ Подсчет очков и штрафов
- ✅ Базовый словарь из файла
- ✅ WebSocket сервер для синхронизации
- ✅ Интерфейс аналогичный Hat Up
- ✅ Подробная статистика команд и игроков
- ✅ Экран представления игрока
- ✅ Счетчик оставшихся слов
- ✅ Корректная очистка данных при завершении игры

### Технические особенности
- **Архитектура**: Pass-and-play на одном устройстве
- **Таймер**: Полностью клиентский с `performance.now()`
- **Данные**: Слова в CSV файле, статистика в памяти
- **UI**: Mobile-first дизайн с анимациями
- **Совместимость**: Обратная совместимость сохранена

### Планы развития
- Сохранение состояния игры
- Глобальная статистика игроков
- Факты о прошедшей партии
- Добавление пользовательских слов
- Черный список
- Самобалансирующаяся сложность
- Рейтинги
- Офлайн режим
- Баланс сложных слов

## 19. Принципы пополнения словаря
- **Оглавление**: первая строка - всегда оглавление.
- **Регистр и язык**: слова фиксируются В ВЕРХНЕМ РЕГИСТРЕ; категории/уровни — в естественном регистре. Язык — русский без транслитераций/англицизмов при наличии устоявшихся аналогов.
- **Формат фраз**: многословные фразы записываются без кавычек; на фронте кавычки не отображаются.
- **Сложность**: не более 20% записей в каждой категории имеют уровень «повышенный», преимущественно для низкочастотных/специализированных терминов (определяется по текущему словарю и здравому смыслу).
- **Дубликаты**: глобально запрещены после нормализации (`ё→е`, удаление пунктуации, схлопывание пробелов). Частично пересекающиеся фразы (типа «электронный будильник» и «будильник») одновременно не допускаются.
- **Обработка дубликатов (оперативно)**: при обнаружении точного дубликата НЕ переименовывать и НЕ переносить — удалить одну из дублей (в любой категории), оставив единственный экземпляр.
- **Категориальные границы**: 
  - «Знаменитости» допускает реальных и вымышленных персонажей.
  - «Архитектура и городская среда» включает стили, элементы и термины, а не только объекты.
  - «Фильмы и сериалы» и «Книги и литература» — без ограничений по типу сущностей (термины и конкретные названия), но без кавычек.
- **Фокус контента**: приоритет русскоязычного контекста при включении международно известных имен/названий.
- **Порядок и сортировка**: словарь хранится отсортированным по категориям и по алфавиту внутри категории. Новые записи при коммите проходят автонормализацию и автосортировку.
- **Ограничения содержания**: тематические ограничения не применяются (политика/острые темы допустимы); в медицине допускаются диагнозы, процедуры, анатомия; избегать коммерческих брендов лекарств.
- **Каденция поставок**: добавление ведётся партиями по ~200 слов на итерацию (2 категории × ~100) с валидацией после каждой итерации.

## 20. Идентификация игроков и статистика (локально)

### 20.1. Идентификация игроков
- **Основной идентификатор**: `telegramUserId` (числовой ID Telegram). В MVP без серверной аутентификации — вводится вручную (поле для ID) или через `@username` с последующим сопоставлением при миграции на сервер.
- **Альтернатива (fallback)**: свободный текст `displayName`. Для долговременного хранения создаётся стабильный ключ `playerKey`:
  - если есть `telegramUserId` → `playerKey = tg:<id>`
  - иначе → `playerKey = name:<sha1(displayName)>` (хэш только для ключа; в отображении используем исходное имя)
- **Модель идентичности (в памяти)**:
```javascript
identity: {
  playerId: string,            // эфемерный ID в рамках сессии
  playerKey: string,           // стабильный ключ для хранилища
  telegramUserId?: string,     // если введён
  displayName: string,         // имя для UI
  displayNameHistory?: string[]
}
```

### 20.2. Слои статистики и срок хранения
- **Статистика сессии (эпhemeral)**:
  - Назначение: экран результатов, «интересные факты», обновление личных статистик.
  - Жизненный цикл: живёт до старта следующей партии; при `start_game` — очищается.
  - Источник истины: событийный лог за сессию (append-only JSONL) + in-memory агрегаты.
- **Статистика игроков (персистентная, «навсегда»)**:
  - Хранение локально в файловой системе; обновляется после каждой партии.
  - Ключ — `playerKey` (см. 20.1). При появлении `telegramUserId` выполняется консолидация дубликатов `name:<hash>` → `tg:<id>`.

### 20.3. Хранилище (локально, без сервера)
- **Событийный лог сессии**: `public/stats/sessions/<gameId>.jsonl` (append-only). Удаляется при старте новой партии.
- **Рантайм‑снимок**: `public/stats/runtime.json` (debounce каждые 3–5с) — для отладки и live‑виджетов.
- **Статистика игроков**: `public/stats/players/<playerKey>.json` — агрегаты по игроку.
- **Лидерборды (кэш)**: `public/stats/leaderboards/<period>.json` — опционально; строятся на лету из in-memory и файлов.
- **Атомарность записи**: запись через временный файл и `rename`; очередь записей для избежания гонок.

### 20.4. Доменная модель агрегатов
```javascript
// Сессия (in-memory, при желании — snapshot в runtime.json)
sessionStats: {
  gameId: string,
  startedAt: number,
  endedAt?: number,
  perTeam: { [teamId: string]: { scoreByRound: {0:number,1:number,2:number}, total: number }},
  perPlayer: { [playerId: string]: { guessed: number, passed: number, totalScore: number, turnCount: number }},
  facts: { longestStreak?: {playerId:string, length:number}, fastestGuess?: {playerId:string, ms:number} }
}

// Игрок (персистентно по playerKey)
playerStats: {
  playerKey: string,
  telegramUserId?: string,
  displayName?: string,
  totals: {
    gamesPlayed: number,
    wins: number,
    wordsGuessed: number,
    wordsPassed: number,
    totalScore: number,
    guessPerMinute?: number
  },
  categories?: { [category: string]: { guessed: number, passed: number }},
  lastPlayedAt?: number
}
```

### 20.5. API и live‑обновления
- **HTTP (чтение)**:
  - `GET /api/stats/session/:gameId` — агрегаты текущей/указанной сессии
  - `GET /api/stats/player/:playerKey` — агрегаты игрока
  - `GET /api/stats/leaderboard?period=7d|30d|all` — лидерборд
- **WebSocket (push)**:
  - `stats:update` — дельты по сессии (для вьюшек на экране игры)
  - `leaderboard:update` — дельты лидерборда при изменении агрегатов игроков

### 20.6. Потоки обновления
1. Во время игры: события (`word_guessed`, `word_passed`, `start_turn`, `end_round`) → запись в event log → обновление in-memory агрегатов → push `stats:update`.
2. При завершении игры: расчёт «фактов» → показ результатов → применение дельт к `playerStats` (по `playerKey`) → перегенерация лидерборда → push `leaderboard:update`.
3. При старте новой игры (`start_game`): удалить `public/stats/sessions/<gameId>.jsonl` предыдущей партии и очистить `sessionStats`.

### 20.7. Конфиденциальность
- Сохраняется только `telegramUserId` и агрегированные игровые метрики. Реальные имена хранятся опционально для удобства UI.
- При fallback‑ключе `name:<sha1>` личные данные (имя) не используются как идентификатор хранения.

### 20.8. Критерии приёмки (статистика/идентичность)
- Ввод игрока по `telegramUserId` или имени; формирование стабильного `playerKey`.
- Статистика сессии очищается на старте следующей партии.
- Статистика игроков обновляется после каждой партии и сохраняется на диск.
- Live‑лидерборды обновляются в реальном времени через WebSocket.
- При появлении `telegramUserId` у игрока с ранее сохранённым `name:<sha1>` — консолидация статистики в единый профиль.

### 20.9. План внедрения
- Шаг 1: Ввести `StatsService` и `StatsRepository` (файловая реализация), хуки из use cases.
- Шаг 2: HTTP‑эндпоинты и WebSocket push для `stats:update` и `leaderboard:update`.
- Шаг 3: Мини‑виджеты live‑статистики и лидерборда в UI.
- Шаг 4: Консолидация профилей при вводе `telegramUserId`.

### 20.10. Интеграция с Telegram ботом (этапность)
- **MVP (сейчас)**: бот‑логин и старт сессии через бота — не реализуем (не даёт ценности на MVP и нет сервера). Идентификация по `telegramUserId` или имени остаётся.
- **После миграции на сервер**:
  - Webhook’и бота: создание/управление сессиями, приглашения, результаты.
  - Telegram Login / WebApp и deep‑links для авторизации и подключения к комнатам.

### 20.11. Лидерборды и метрики (только «за всё время»)
- **Политика периода**: только «all‑time». Без 7/30 дней на MVP.
- **Формирование**: из персистентных `playerStats` (агрегаты), кэшируемые таблицы по каждой метрике.
- **Метрики (расширяемый реестр)**:
  - Всего игр (`gamesPlayed`)
  - Winrate (`wins/gamesPlayed` при наличии определения победителя)
  - Лучший результат 2‑го раунда (персональный рекорд по сессии)
  - Медианная скорость (сек/слово) в 1‑м раунде (median SPW R1)
  - Самая длинная полоса побед
  - Всего угаданных слов
  - Скорость по раундам: «секунд на слово» (Seconds Per Word, SPW) — см. 20.13. Без GPM. Агрегация — медиана SPW.
- **Представление**: множество таблиц-лидербордов (по 1 на метрику). Обновление по WebSocket `leaderboard:update` дельтами (только изменившиеся строки/позиции).
  - Для серий побед в лидерборде учитывается только лучшая (историческая) серия по каждому игроку.
  - Для SPW‑таблиц тай‑брейкеры: 1) больше угаданных слов (desc), 2) меньше суммарного активного времени (asc).

### 20.12. Правила определения победителя и ничьих
- Победителем считается команда с максимальным итоговым счётом.
- При ничьей побеждают все команды, разделившие максимум. Игрокам в этих командах засчитывается победа для winrate и серий.

### 20.13. Учёт активного времени и «секунд на слово» (SPW)
- **Проблема**: фиксированные длительности хода и разные количества игроков и попыток искажают эффективность, если считать «очки за ход/раунд».
- **Решение**: измеряем фактическое активное время игрока по раундам и считаем SPW = \(\frac{секунды\_активной\_игры}{угаданные\_слова}\) для раунда и агрегатов.
- **Источник времени**: внутриигровой таймер, который ставится на паузу вместе с игрой. События: `START_TURN` → `PAUSE/RESUME` → `END_TURN`/`ROUND_DEPLETED`.
- **Сбор**:
  - На `START_TURN`: фиксируем `turnStartedAt`.
  - На `PAUSE`: фиксируем дельту и добавляем в `activeMs` текущему игроку/раунду; помечаем `paused=true`.
  - На `RESUME`: фиксируем `resumeAt`, `paused=false`.
  - На `END_TURN`/исчерпание слов: добавляем финальную дельту.
  - Исключаем неактивные промежутки (паузы, переходные экраны).
- **Агрегация**:
  - По сессии/раунду/игроку: `activeMs`, `guessedCount` → `spw = activeMs / 1000 / max(1, guessedCount)`.
  - Для агрегатов «за всё время» используем медиану SPW по наборам значений (устойчива к выбросам). Для витрин по раундам — медиана SPW по соответствующему раунду.
  - «Лучший 2‑й раунд» — минимальный `spw` в раунде 2.
- **Лидерборд**: чем меньше `spw`, тем лучше позиция.
- **Нулевые угадывания**: если `guessedCount = 0`, SPW не определяется — в UI показываем «—», из SPW‑лидербордов игрок исключается до первого угаданного слова.

### 20.15. Отображение статистики в UI
- **Личные результаты в конце игры (сессионные)**: показываем только количество очков игрока за текущую игровую сессию.
- **Глобальная статистика игрока (all‑time)**: детальные метрики — игры, победы/winrate (с учётом ничьих), рекорды по раундам, медианные SPW по каждому раунду, лучшая серия побед и текущая серия побед. Источник данных на локальном этапе — файловое хранилище через локальные API; после миграции — БД.

### 20.14. Миграция на удалённый сервер с БД
- **Абстракции**: `StatsRepository`/`IdentityRepository` с файловой реализацией сейчас (`File*Repository`) и `Db*Repository` потом.
- **БД (рекомендация)**: PostgreSQL.
- **Схема (набросок)**:
  - `players(player_id pk, telegram_user_id unique null, display_name, created_at)`
  - `player_stats(player_id fk, totals jsonb, categories jsonb, last_played_at, primary key (player_id))`
  - `games(game_id pk, started_at, ended_at, meta jsonb)`
  - `game_events(game_id fk, seq, ts, type, payload jsonb, primary key (game_id, seq))`
- **Миграция данных**: импорт файлов `public/stats/players/*.json` в `players`/`player_stats`; консолидация `name:<sha1>` → `tg:<id>` на уровне ETL.
- **Бот**: сервер принимает webhook от Telegram, управляет сессиями и авторизацией, фронт подключается к комнате/игре через сервер.