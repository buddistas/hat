# Hat Web — План проекта (RU)

## Оглавление
- [1. Цели и ограничения](#1-цели-и-ограничения)
- [2. Технологический стек](#2-технологический-стек)
- [3. Основные поставки (MVP)](#3-основные-поставки-mvp)
- [4. Этапы и сроки](#4-этапы-и-сроки)
- [5. Команды](#5-команды)
- [6. Структура приложения](#6-структура-приложения)
- [7. Реализация правил игры](#7-реализация-правил-игры)
- [8. Структура данных](#8-структура-данных-текущая-реализация)
- [9. Нормализация слов](#9-нормализация-слов)
- [10. Состояния игры](#10-состояния-игры)
- [11. Таймер и перенос времени](#11-таймер-и-перенос-времени)
- [12. Распределение и порядок слов](#12-распределение-и-порядок-слов)
- [13. Экраны и UX‑особенности](#13-экраны-и-uxособенности)
- [14. Аналитика и статистика](#14-аналитика-и-статистика)
- [15. План тестирования](#15-план-тестирования)
- [16. Производительность и доступность](#16-производительность-и-доступность)
- [17. Критерии приёмки (MVP)](#17-критерии-приёмки-mvp)
- [18. Текущий статус проекта](#18-текущий-статус-проекта)
 - [19. Принципы пополнения словаря](#19-принципы-пополнения-словаря)
 - [20. Идентификация игроков и статистика (локально)](#20-идентификация-игроков-и-статистика-локально)

---

## 1. Цели и ограничения
- **Тип игры**: Настольная игра на одном устройстве, передаваемая от игрока к игроку (однопользовательское приложение)
- **Синхронизация**: Не требуется, игра работает на одном устройстве без серверной зависимости
- **Безопасность**: Игроки не используют читы, безопасность не критична
- **Сетевые условия**: Не принципиальны, цель - минимизировать зависимость от интернета
- **Архитектура**: Клиентская реализация логики переноса времени для автономности
- Один девайс, режим pass-and-play; 4–20 игроков суммарно.
- Три раунда: 1) свободное объяснение, 2) жесты/мимика, 3) одно слово.
- Ход 60 секунд; PASS = −1 очко; угаданное = +1 очко.
- Раунд заканчивается, когда «шляпа» пуста; игра завершается, когда пуста шляпа в раунде 3.
- Перенос времени между раундами (ceil до секунды); следующий раунд начинает тот же игрок, и первая попытка использует только перенесённые секунды (без базовых 60s).
- Базовый словарь RU; брендовые названия отображаются в оригинале (латиницей), нормализация особым путём.
- Пользовательские слова — отдельная категория внутри базового RU-пака; глобальная дедупликация. Каждое слово (или фраза) может принадлежать только одной категории.
- Mobile-first, портретная ориентация, вибрация + звук, офлайн‑режим с восстановлением.
- Звук обязателен для игрового опыта; приложение не предоставляет «тихий режим».
- На экране хода доступна пауза/возобновление для ведущего игрока.
- Ответы подтверждаются вручную: текущий игрок нажимает «Верно», приложение не анализирует корректность ответа.
- Глобальная статистика и Telegram‑аутентификация — на серверной фазе.

## 2. Технологический стек (MVP - упрощенный)
- Frontend: Vanilla HTML/CSS/JavaScript с WebSocket подключением для реактивности
- Backend: Node.js с WebSocket сервером для раздачи статической страницы и обработки JSON событий
- Таймер: Полностью клиентский с `performance.now()` + `requestAnimationFrame`
- Данные: Слова в отдельном файле через запятую (один файл, все слова в одной строке)
- UI: Интерфейс аналогичный приложению Hat Up (http://apps.apple.com/ru/app/hat-up/id1472656524)
- Архитектура: Одна комната, многопользовательская игра на одном устройстве (pass-and-play)

## 3. Основные поставки (MVP)
- MVP: полный 3‑раундный цикл, таймер с переносом, подсчёт очков/штрафы, базовый словарь из файла, итоги с «интересными фактами», вибро/звук
- WebSocket сервер: раздача статической страницы, обработка JSON событий между клиентом и сервером
- Интерфейс: повторение UI приложения Hat Up для знакомого пользовательского опыта
- Архитектура: pass-and-play на одном устройстве, одна комната для всех игроков

## 4. Этапы и сроки
- M1: Node.js WebSocket сервер + статическая HTML страница с базовым UI. (1 день)
- M2: Игровая логика: 3 раунда, таймер с переносом, подсчёт очков, базовый словарь из файла. (1 день)
- M3: WebSocket события: JSON коммуникация между клиентом и сервером. (1 день)
- M4: UI аналогичный Hat Up: экраны настройки, игры, результатов. (1 день)
- M5: Звук, вибрация, пауза/возобновление, финальная полировка. (1 день)

## 5. Команды
- Количество команд: 2–4.
- Размер команды: от 2 до 5 игроков.
- Балансировка: максимальная разница в численности между командами — 1 игрок.
- Распределение игроков:
  - Кнопка авто‑распределения по командам с возможностью повторного реролла.
  - Возможность ручного заполнения/редактирования составов.

## 6. Структура приложения
```
hat_web/
  server.js          # Node.js WebSocket сервер
  package.json       # Зависимости Node.js
  public/
    index.html       # Статическая страница с встроенным CSS/JS
    words.csv        # Словарь через запятую
```

## 7. Реализация правил игры
- Общий пул слов на всю игру; каждый раунд переиспользует слова, пока все не будут угаданы.
- `PASS` немедленно снижает очки команды на 1 (−1) и фиксируется в логе событий.
- Перенос времени (carry‑over):
  - Если раунд исчерпан во время активного хода, следующий раунд начинает тот же игрок с ceil(remainingSeconds).
  - Первая попытка следующего раунда использует только перенесённые секунды (без базовых 60s).
  - Все последующие попытки в раунде — стандартные 60s.
  - Если раунд завершился ровно в момент истечения хода (time up), перенос не применяется.
  - **Время НЕ переносится между играми** - очищается при завершении партии.
  - **Данные очищаются при завершении игры** - предотвращает накопление и утечки памяти.
- Очки могут уходить в отрицательные значения; нижних границ нет.

### 7.1. Логика очередности ходов
- **Инициализация очереди**: При старте игры формируется фиксированная очередь ходов:
  - Случайный порядок команд (перемешивание массива команд)
  - Случайный порядок игроков внутри каждой команды
  - Структура данных `turnOrder`:
    ```js
    turnOrder: {
      teams: [], // Порядок команд (случайный)
      playersByTeam: {}, // Порядок игроков внутри каждой команды (случайный)
      currentTeamIndex: 0, // Индекс текущей команды в очереди
      currentPlayerIndex: 0 // Индекс текущего игрока в команде
    }
    ```

- **Алгоритм переключения ходов**:
  1. Ход переходит к следующей команде в очереди (`currentTeamIndex++`)
  2. Если достигнут конец списка команд (`currentTeamIndex === 0`), переходим к следующему игроку (`currentPlayerIndex++`)
  3. Если индекс игрока превышает количество игроков в команде, сбрасываем на 0
  4. Выбираем игрока: `teams[currentTeamIndex].playersByTeam[currentPlayerIndex]`

- **Перемешивание слов при смене игрока**:
  - При каждом переходе хода к новому игроку слова в пуле перемешиваются заново
  - Используется алгоритм Fisher-Yates для равномерного распределения
  - Пропущенные слова остаются в пуле и могут достаться любому игроку

- **Экран представления игрока**:
  - Показывается перед каждым ходом игрока, включая первый
  - Отображает имя текущего игрока и его команду
  - Имеет красивую анимацию появления с эффектом свечения
  - Позволяет игрокам подготовиться к своему ходу
  - Переходит к игровому экрану по нажатию кнопки "Начать"

- **Экран передачи хода**:
  - Показывается между ходами игроков для плавного перехода
  - Отображает имя следующего игрока и его команду
  - Позволяет игрокам подготовиться к своему ходу
  - Автоматически переходит к экрану представления игрока по нажатию "Старт"

- **Правило повторной выдачи PASS-слов**:
  - Пропущенные слова перемещаются в конец очереди `availableWords`
  - Могут достаться тому же игроку только если в пуле не осталось других слов
  - Статистика пропусков ведется отдельно для аналитики

## 8. Структура данных (текущая реализация)

### gameState (сервер)
```javascript
{
  gameId: string,
  players: Array<{id: string, name: string, teamId: string}>,
  teams: Array<{id: string, name: string, playerIds: string[]}>,
  currentRound: 0 | 1 | 2,
  currentPlayer: {id: string, name: string, teamId: string},
  currentWord: string | null,
  availableWords: string[],
  usedWords: string[],
  teamStatsByRound: {
    0: {[teamId: string]: number},
    1: {[teamId: string]: number}, 
    2: {[teamId: string]: number}
  },
  playerStats: {
    [playerId: string]: {
      guessed: number,
      passed: number,
      totalScore: number
    }
  },
  playerCarriedTime: {[playerId: string]: number} // Очищается при завершении игры
}
```

## 9. Нормализация слов
- Регистр: в хранимом CSV все СЛОВА (первая колонка) фиксируются В ВЕРХНЕМ РЕГИСТРЕ; категории и уровень сохраняют исходный регистр/написание.
- Кириллица: upperCase → trim → нормализация пробелов (схлопывание) → нормализация тире (– — − → `-`) и апострофов (’ ` ´ → `'`) → trim. «Ё» при сортировке приравнивается к «Е» (колляция ru, sensitivity=base).
- Бренды (латиница): переводятся в верхний регистр, спецсимволы не изменяются, кроме нормализации пробелов/апострофов/тире.
- Пользовательские слова: дефис/тире и апостроф разрешены; эмодзи запрещены.
- В исходном базовом словаре разрешены любые символы (кроме эмодзи в пользовательском вводе).
- Дедуп-линия: точные дубли записей (слово+категория+уровень после нормализации) удаляются.

## 10. Состояния игры
- Состояния: `lobby` → `setup` → `preround(r)` → `handoff` → `turnActive` → `turnEnd` → `roundReview` → `roundEnd` → `preround(r+1)` → … → `gameSummary`
- События: `GAME_CREATED`, `TEAMS_CONFIGURED`, `START_ROUND`, `START_TURN`, `PAUSE`, `RESUME`, `GUESS_OK`, `PASS`, `TIMER_TICK`, `TIMER_EXPIRED`, `END_TURN`, `ROUND_DEPLETED`, `CARRY_TIME`, `START_NEXT_ROUND`, `END_GAME`

## 11. Таймер и перенос времени
- **Архитектура**: Полностью клиентский таймер с использованием `performance.now()` + `requestAnimationFrame`.
- **Хранение времени**: Использование `localStorage` для сохранения перенесенного времени между раундами
- **Корректировка**: Автоматическая корректировка через событие `visibilitychange` при возвращении в фокус.
- **Формулы**:
  - `remainingTime = max(0, duration - (now - startTime))`
  - `carry = ceil(remainingTime / 1000)` — перенос времени между раундами (в секундах)
  - На старте 2‑го и 3‑го раунда применяется правило минимума: если перенесённое время `carry ∈ (0;5)`, то используется `5` секунд. Это реализовано на стороне сервера в `src/entities/Game.js` при переходе раунда (`currentRound === 1 || currentRound === 2`).
- **Особенности**:
  - Точность до миллисекунд
  - Устойчивость к проблемам фоновых вкладок
  - Поддержка паузы/возобновления
  - Перенос времени только на первую попытку следующего раунда
  - **Автономность**: Полная независимость от сервера для логики времени
  - **Надежность**: Работает без интернет-соединения
  - **Очистка данных**: Время НЕ переносится между играми, очищается при завершении партии

## 12. Распределение и порядок слов
- Порядок слов в каждом раунде — случайный.
- Равномерность выдачи между игроками не гарантируется.
- Пропущенное слово может вновь достаться тому же игроку только если в шляпе не осталось других слов.
 - Подтверждение угадывания выполняется вручную: ведущий нажимает «Верно» при слышимом правильном ответе.

### 12.1. Порядок и сортировка словаря (CSV)
- Формат CSV: `слово,категория,уровень` (без заголовка или с заголовком — опционально).
- Сортировка: сначала по категории (алфавит `ru`, `sensitivity=base`), затем по слову (алфавит `ru`, `sensitivity=base`).
- Уровень (`обычный`/`повышенный`) не влияет на порядок сортировки.
- При записи соблюдается верхний регистр только для колонки «слово».

## 13. Экраны и UX‑особенности
- Start/Lobby, Setup (имена 1–24 символа; 4–20 игроков; имя обязательно; опционально `@username`), Rules, PlayerIntro (экран представления игрока с анимацией), Handoff, Turn (крупное слово, таймер, кнопки `Угадано`/`Пас`), Review, Results, Dictionary, Settings.
- Раунд 2 без текстовых подсказок (только жесты/мимика).
- Вибро: старт(60ms), T−5s([30,40,30]), guessed/pass(25ms), конец(120ms).
- Звук: обязателен. Короткий стартовый сигнал, одиночный на `T−5s`, длинный на окончание, клики кнопок (прелоад). Экран первичного «разблокирования аудио» по первому тапу. Отдельного «тихого режима» нет.
- Учитывать системные настройки по возможности, но отдельного «тихого режима» нет.
- На экране хода — кнопка `Пауза/Возобновить`; при паузе блокируются все кнопки, кроме паузы и завершения игры; блокировка снимается при завершении/инициализации игры.
- **Счетчик слов**: Отображение "Еще слов - X" на экране хода с динамическим обновлением и цветовой индикацией (красный ≤10, оранжевый 11-25, желтый >25 слов).

## 14. Аналитика и статистика
- **Статистика команд**: очки по раундам (teamStatsByRound), общий счет, определение победителя
- **Личная статистика игроков**: количество угаданных слов, пропущенных слов, общие очки
- **Отображение**: два переключаемых экрана с таблицами статистики в финальных результатах
- **Цветовая индикация**: зеленый (положительные очки), красный (отрицательные), серый (ноль)

## 15. План тестирования
- Unit: клиентский таймер, подсчёт с −1 за PASS, переиспользование пула между раундами, нормализация/дедуп
- Component: Turn (моки таймера/вибро/звука), Review, Dictionary (валидация/ошибки)
- E2E: полный 3‑раундный матч с переносом, восстановление после перезагрузки, сценарий Пауза/Возобновить

## 16. Производительность и доступность
- Мемоизация, минимум лишних перерисовок, предзагрузка аудио
- Высокая контрастность, крупные тач‑таргеты, ARIA по необходимости
- Портретная ориентация; мягкие подсказки при повороте устройства

## 17. Критерии приёмки (MVP)
- Полный 3‑раундный цикл с переносом времени (ceil) и штрафами.
- Корректная очистка времени при завершении игры (предотвращение утечек памяти).
- 2–4 команды; 2–5 игроков в команде; макс. разница между командами — 1 игрок.
- Авто‑распределение с рероллом и ручное редактирование составов.
- PASS даёт −1 очко; возможны отрицательные очки.
- Пользовательские слова — отдельная категория; дедуп работает для кириллицы/латиницы; эмодзи запрещены.
- Порядок слов — случайный; правило повторной выдачи PASS‑слова соблюдается.
- Звук обязателен; вибро и звук работают в критических точках; экран разблокировки аудио; отдельного «тихого режима» нет.
- RU‑локализация; офлайн‑режим; восстановление сессии.
- На экране хода доступна пауза/возобновление; во время паузы действия заблокированы, события логируются.
- Подтверждение угадывания выполняется вручную кнопкой «Верно» текущего игрока; автоматическая проверка отсутствует.
- Тесты: ключевые unit/component + минимум 3 E2E‑сценария (полный матч, восстановление, пауза/мьют/распределение).

## 18. Текущий статус проекта

### Реализованные функции (MVP)
- ✅ Полный 3-раундный цикл игры
- ✅ Таймер с переносом времени между раундами
- ✅ Подсчет очков и штрафов
- ✅ Базовый словарь из файла
- ✅ WebSocket сервер для синхронизации
- ✅ Интерфейс аналогичный Hat Up
- ✅ Подробная статистика команд и игроков
- ✅ Экран представления игрока
- ✅ Счетчик оставшихся слов
- ✅ Корректная очистка данных при завершении игры

### Технические особенности
- **Архитектура**: Pass-and-play на одном устройстве
- **Таймер**: Полностью клиентский с `performance.now()`
- **Данные**: Слова в CSV файле, статистика в памяти
- **UI**: Mobile-first дизайн с анимациями
- **Совместимость**: Обратная совместимость сохранена

### Планы развития
- Сохранение состояния игры
- Глобальная статистика игроков
- Факты о прошедшей партии
- Добавление пользовательских слов
- Черный список
- Самобалансирующаяся сложность
- Рейтинги
- Офлайн режим
- Баланс сложных слов
- Метрика процентажа угаданных сложных слов + соответствующая стата после игры.
- Возможность редактировать состав команды прямо по ходу матча

## 21. Telegram-бот для управления игрой

### 21.1. Цели и функциональность
- **Основная цель**: Удобное управление игрой через Telegram-бота
- **Функции**: Запуск игры, добавление участников, завершение игры
- **Интеграция**: Бот работает как интерфейс к веб-игре, не заменяя её

### 21.2. Архитектура
- **Интеграция**: Встроен в существующий Node.js сервер
- **Библиотека**: `node-telegram-bot-api` (polling по умолчанию; webhook — на продакшене)
- **Синхронизация**: HTTP API + WebSocket для реального времени
- **Конфигурация**: файл `telegram-config.js` (переключение бота, `GAME_URL`, лог‑настройки). При отсутствии токена бот автоматически отключается, сервер продолжает работать.
- **GAME_URL**: базовый URL игры, используемый в кнопке‑ссылке. Для локальной разработки необходимо использовать публичный HTTPS‑tunnel (ngrok) — Telegram отклоняет `http://localhost` в inline‑кнопках.

### 21.3. Интерфейс бота
```
🎮 Управление игрой

[🎯 Старт] [👥 Присоединиться]
[❌ Отключиться] [🛑 Завершить игру]
```

### 21.4. Логика работы кнопок
- **"Старт"**: 
  - Активна только когда нет активной игры
  - При нажатии отправляет гиперссылку для автоматического открытия браузера
  - Ссылка формируется как: `<GAME_URL>?autoJoin=true&username=@username&gameId=<id>`
  - ВАЖНО: в Telegram inline‑кнопках допустимы только публичные HTTPS URL. Для локальной отладки используйте ngrok URL вида `https://<subdomain>.ngrok.io` вместо `http://localhost:4000` в `GAME_URL`.
  - После нажатия становится неактивной до завершения игры

- **"Присоединиться"**:
  - Активна после настройки количества игроков в веб-интерфейсе
  - Блокируется после выдачи первого слова игры
  - Добавляет игрока в список участников

- **"Отключиться"**:
  - Активна когда игрок в списке участников
  - Удаляет игрока из списка

- **"Завершить игру"**:
  - Активна во время активной игры
  - Требует ввод кода "1104" для подтверждения
  - Завершает игру принудительно

### 21.5. Механизм работы
1. Пользователь нажимает "Старт" в боте
2. Бот отправляет гиперссылку с параметрами для автоматического добавления
3. Telegram открывает браузер с ссылкой на игру (через inline‑кнопку URL; требуется публичный HTTPS URL)
4. Веб-страница автоматически добавляет пользователя в список игроков
5. Другие пользователи могут присоединяться через бота
6. Список участников обновляется в реальном времени через WebSocket

### 21.6. Уведомления
- **Начало игры**: "🎮 Игра началась! Присоединяйтесь через кнопки ниже"
- **Завершение игры**: "🏁 Игра завершена. Спасибо за участие!"
- **Успешные действия**: "✅ Вы успешно присоединились к игре"
 - Уведомления включены по умолчанию в боте; в дальнейшем можно вынести в конфигурацию.

### 21.7. Обработка ошибок
- **Попытка запуска при активной игре**: "Игра уже запущена. Завершите текущую игру перед запуском новой"
- **Попытка присоединения к полной игре**: "Игра уже набрала максимальное количество участников"
- **Попытка отключения не участвуя**: "Вы не участвуете в текущей игре"

### 21.8. Логирование
- **События**: Запуск игры, присоединение игроков, завершение игры
- **Формат**: JSON с временными метками
- **Хранение**: Файл `logs/telegram-bot.log` на сервере
 - Пример служебных сообщений: `polling_error EFATAL`, `getaddrinfo ENOTFOUND api.telegram.org` — см. 21.12.

### 21.9. API эндпоинты для бота
- `GET /api/game/status` - статус игры (активна/неактивна, количество участников)
- `POST /api/game/start` - запуск новой игры
- `POST /api/game/join` - присоединение игрока
- `POST /api/game/leave` - отключение игрока
- `POST /api/game/end` - принудительное завершение игры

### 21.10. Тестирование
- **Локальная разработка**: `http://localhost:4000`
- **Туннелирование**: ngrok обязателен для тестирования inline‑кнопки URL в Telegram (нужен публичный HTTPS). Используйте URL ngrok в `GAME_URL`.
- **Продакшн**: Удаленный сервер с реальным доменом

### 21.11. Безопасность
- **Доступ**: Открытый доступ для всех пользователей
- **Валидация**: Проверка корректности действий через API
- **Логирование**: Все действия записываются для аудита

### 21.12. Отладка и типовые проблемы
- **400 Bad Request: Wrong HTTP URL** при нажатии "Старт": Telegram отклоняет `http://localhost`. Установите `GAME_URL` на публичный HTTPS (ngrok/домен).
- **polling_error EFATAL / ECONNRESET / ENOTFOUND api.telegram.org**: проверьте доступ к `api.telegram.org` (DNS/файрвол), стабильность сети, корректность токена.
- **"query is too old"**: обработка callback заняла слишком много времени. Формируйте ответ/редактирование сообщения в течение ~2–3 секунд.
- **Кнопка "Старт" не активна**: активная игра уже идёт — завершите её (код подтверждения 1104).


## 19. Принципы пополнения словаря
- **Оглавление**: первая строка - всегда оглавление.
- **Регистр и язык**: слова фиксируются В ВЕРХНЕМ РЕГИСТРЕ; категории/уровни — в естественном регистре. Язык — русский без транслитераций/англицизмов при наличии устоявшихся аналогов.
- **Формат фраз**: многословные фразы записываются без кавычек; на фронте кавычки не отображаются.
- **Сложность**: не более 20% записей в каждой категории имеют уровень «повышенный», преимущественно для низкочастотных/специализированных терминов (определяется по текущему словарю и здравому смыслу).
- **Дубликаты**: глобально запрещены после нормализации (`ё→е`, удаление пунктуации, схлопывание пробелов). Частично пересекающиеся фразы (типа «электронный будильник» и «будильник») одновременно не допускаются.
- **Обработка дубликатов (оперативно)**: при обнаружении точного дубликата НЕ переименовывать и НЕ переносить — удалить одну из дублей (в любой категории), оставив единственный экземпляр.
- **Категориальные границы**: 
  - «Знаменитости» допускает реальных и вымышленных персонажей.
  - «Архитектура и городская среда» включает стили, элементы и термины, а не только объекты.
  - «Фильмы и сериалы» и «Книги и литература» — без ограничений по типу сущностей (термины и конкретные названия), но без кавычек.
- **Фокус контента**: приоритет русскоязычного контекста при включении международно известных имен/названий.
- **Порядок и сортировка**: словарь хранится отсортированным по категориям и по алфавиту внутри категории. Новые записи при коммите проходят автонормализацию и автосортировку.
- **Ограничения содержания**: тематические ограничения не применяются (политика/острые темы допустимы); в медицине допускаются диагнозы, процедуры, анатомия; избегать коммерческих брендов лекарств.
- **Каденция поставок**: добавление ведётся партиями по ~200 слов на итерацию (2 категории × ~100) с валидацией после каждой итерации.

## 20. Идентификация игроков и статистика (локально)

### 20.1. Идентификация игроков
- **Основной идентификатор**: `telegramUserId` (числовой ID Telegram). В MVP без серверной аутентификации — вводится вручную (поле для ID) или через `@username` с последующим сопоставлением при миграции на сервер.
- **Альтернатива (fallback)**: свободный текст `displayName`. Для долговременного хранения создаётся стабильный ключ `playerKey`:
  - если есть `telegramUserId` → `playerKey = tg:<id>`
  - иначе → `playerKey = name:<sha1(normalizedDisplayName)>`, где `normalizedDisplayName = lower(trim(name))` (хэш только для ключа; в отображении используем исходное имя)
- **Модель идентичности (в памяти)**:
```javascript
identity: {
  playerId: string,            // эфемерный ID в рамках сессии
  playerKey: string,           // стабильный ключ для хранилища
  telegramUserId?: string,     // если введён
  displayName: string,         // имя для UI
  displayNameHistory?: string[]
}
```

### 20.2. Слои статистики и срок хранения
- **Статистика сессии (эпhemeral)**:
  - Назначение: экран результатов, «интересные факты», обновление личных статистик.
  - Жизненный цикл: живёт до старта следующей партии; при `start_game` — очищается.
  - Источник истины: событийный лог за сессию (append-only JSONL) + in-memory агрегаты.
- **Статистика игроков (персистентная, «навсегда»)**:
  - Хранение локально в файловой системе; обновляется после каждой партии.
  - Ключ — `playerKey` (см. 20.1). При появлении `telegramUserId` выполняется консолидация дубликатов `name:<hash>` → `tg:<id>`.

### 20.3. Хранилище (локально, без сервера)
- **Событийный лог сессии**: `public/stats/sessions/<gameId>.jsonl` (append-only). Удаляется при старте новой партии.
- **Рантайм‑снимок**: `public/stats/runtime.json` (debounce каждые 3–5с) — для отладки и live‑виджетов.
- **Статистика игроков**: `public/stats/players/<playerKey>.json` — агрегаты по игроку.
- **Лидерборды (кэш)**: `public/stats/leaderboards/<period>.json` — опционально; строятся на лету из in-memory и файлов.
- **Атомарность записи**: запись через временный файл и `rename`; очередь записей для избежания гонок.

### 20.4. Доменная модель агрегатов
```javascript
// Сессия (in-memory, при желании — snapshot в runtime.json)
sessionStats: {
  gameId: string,
  startedAt: number,
  endedAt?: number,
  perTeam: { [teamId: string]: { scoreByRound: {0:number,1:number,2:number}, total: number }},
  perPlayer: { [playerId: string]: { guessed: number, passed: number, totalScore: number, turnCount: number }},
  facts: { 
    longestStreak?: {playerId:string, length:number}, 
    fastestGuess?: {playerId:string, ms:number},
    mostPassedWord?: {word:string, count:number},
    hardestWord?: {word:string, totalTimeMs:number} // формируется из sessionStats.wordTracking.wordDisplayTime; учитывается и последнее слово раунда благодаря finalizeCurrentWordDisplay()
  },
  // Новые метрики сессии
  wordTracking: {
    passedWords: { [word: string]: number }, // счетчик пропусков по словам
    wordDisplayTime: { [word: string]: number } // суммарное время показа слова в секундах
  },
  duration: {
    roundDurations: { 0: number, 1: number, 2: number }, // продолжительность раундов в секундах
    totalGameDuration: number // общая продолжительность партии в секундах
  },
  // Временные переменные для отслеживания
  _currentWord: string | null, // текущее показываемое слово
  _wordShownAt: number | null // время показа текущего слова
}

// Игрок (персистентно по playerKey)
playerStats: {
  playerKey: string,
  telegramUserId?: string,
  displayName?: string,
  totals: {
    gamesPlayed: number,
    wins: number,
    wordsGuessed: number,
    wordsPassed: number,
    totalScore: number,
    guessPerMinute?: number
  },
  categories?: { [category: string]: { guessed: number, passed: number }},
  lastPlayedAt?: number
}
```

### 20.5. API и live‑обновления
- **HTTP (чтение)**:
  - `GET /api/stats/session/:gameId` — агрегаты текущей/указанной сессии
  - `GET /api/stats/player/:playerKey` — агрегаты игрока
  - `GET /api/stats/leaderboard?period=7d|30d|all` — лидерборд
- **WebSocket (push)**:
  - `stats:update` — дельты по сессии (для вьюшек на экране игры)
  - `leaderboard:update` — дельты лидерборда при изменении агрегатов игроков

### 20.6. Потоки обновления
1. Во время игры: события (`word_guessed`, `word_passed`, `start_turn`, `end_round`) → запись в event log → обновление in-memory агрегатов → обновление метрик слов и времени → push `stats:update`.
2. При завершении игры: расчёт «фактов» (включая самые часто пропускаемые и сложные слова) → показ результатов → применение дельт к `playerStats` (по `playerKey`) → перегенерация лидерборда → push `leaderboard:update`.
3. При старте новой игры (`start_game`): удалить `public/stats/sessions/<gameId>.jsonl` предыдущей партии и очистить `sessionStats` (включая новые метрики).

### 20.7. Конфиденциальность
- Сохраняется только `telegramUserId` и агрегированные игровые метрики. Реальные имена хранятся опционально для удобства UI.
- При fallback‑ключе `name:<sha1>` личные данные (имя) не используются как идентификатор хранения.

### 20.8. Критерии приёмки (статистика/идентичность)
- Ввод игрока по `telegramUserId` или имени; формирование стабильного `playerKey`.
- Статистика сессии очищается на старте следующей партии.
- Статистика игроков обновляется после каждой партии и сохраняется на диск.
- Live‑лидерборды обновляются в реальном времени через WebSocket.
- При появлении `telegramUserId` у игрока с ранее сохранённым `name:<sha1>` — консолидация статистики в единый профиль.

### 20.9. План внедрения
- Шаг 1: Ввести `StatsService` и `StatsRepository` (файловая реализация), хуки из use cases.
- Шаг 2: HTTP‑эндпоинты и WebSocket push для `stats:update` и `leaderboard:update`.
- Шаг 3: Мини‑виджеты live‑статистики и лидерборда в UI.
- Шаг 4: Консолидация профилей при вводе `telegramUserId`.

### 20.10. Интеграция с Telegram ботом (этапность)
- **MVP (сейчас)**: бот‑логин и старт сессии через бота — не реализуем (не даёт ценности на MVP и нет сервера). Идентификация по `telegramUserId` или имени остаётся.
- **После миграции на сервер**:
  - Webhook’и бота: создание/управление сессиями, приглашения, результаты.
  - Telegram Login / WebApp и deep‑links для авторизации и подключения к комнатам.

### 20.11. Лидерборды и метрики (только «за всё время»)
- **Политика периода**: только «all‑time». Без 7/30 дней на MVP.
- **Формирование**: из персистентных `playerStats` (агрегаты), кэшируемые таблицы по каждой метрике.
- **Метрики (расширяемый реестр)**:
  - Всего игр (`gamesPlayed`)
  - Winrate (`wins/gamesPlayed` при наличии определения победителя)
  - Лучший результат 1‑го раунда (персональный рекорд по сессии)
  - Лучший результат 2‑го раунда (персональный рекорд по сессии)
  - Лучший результат 3‑го раунда (персональный рекорд по сессии)
  - Медианная скорость (сек/слово) в 1‑м раунде (median SPW R1)
  - Медианная скорость (сек/слово) во 2‑м раунде (median SPW R2)
  - Медианная скорость (сек/слово) в 3‑м раунде (median SPW R3)
  - Самая длинная полоса побед
  - Текущая полоса побед (в личной карточке)
  - Максимум баллов за партию (персональный рекорд)
  - Скорость по раундам: «секунд на слово» (Seconds Per Word, SPW) — см. 20.13. Без GPM. Агрегация — медиана SPW.
  - Максимум пропущенных слов за партию (персональный рекорд)
  - Лучший ход 1‑го раунда (максимум баллов за один ход)
  - Лучший ход 2‑го раунда (максимум баллов за один ход)
  - Лучший ход 3‑го раунда (максимум баллов за один ход)
- **Представление**: множество таблиц-лидербордов (по 1 на метрику). Обновление по WebSocket `leaderboard:update` дельтами (только изменившиеся строки/позиции).
  - Для серий побед в лидерборде учитывается только лучшая (историческая) серия по каждому игроку.
  - Для SPW‑таблиц тай‑брейкеры: 1) больше угаданных слов (desc), 2) меньше суммарного активного времени (asc).

### 20.12. Правила определения победителя и ничьих
- Победителем считается команда с максимальным итоговым счётом.
- При ничьей побеждают все команды, разделившие максимум. Игрокам в этих командах засчитывается победа для winrate и серий.

### 20.13. Учёт активного времени и «секунд на слово» (SPW)
- **Проблема**: фиксированные длительности хода и разные количества игроков и попыток искажают эффективность, если считать «очки за ход/раунд».
- **Решение**: измеряем фактическое активное время игрока по раундам и считаем SPW = \(\frac{секунды\_активной\_игры}{угаданные\_слова}\) для раунда и агрегатов.
- **Источник времени**: внутриигровой таймер, который ставится на паузу вместе с игрой. События: `START_TURN` → `PAUSE/RESUME` → `END_TURN`/`ROUND_DEPLETED`.
- **Сбор**:
  - На `START_TURN`: фиксируем `turnStartedAt`.
  - На `PAUSE`: фиксируем дельту и добавляем в `activeMs` текущему игроку/раунду; помечаем `paused=true`.
  - На `RESUME`: фиксируем `resumeAt`, `paused=false`.
  - На `END_TURN`/исчерпание слов: добавляем финальную дельту.
  - Исключаем неактивные промежутки (паузы, переходные экраны).
- **Агрегация**:
  - По сессии/раунду/игроку: `activeMs`, `guessedCount` → `spw = activeMs / 1000 / max(1, guessedCount)`.
  - Для агрегатов «за всё время» используем медиану SPW по наборам значений (устойчива к выбросам). Для витрин по раундам — медиана SPW по соответствующему раунду.
  - «Лучший 2‑й раунд» — минимальный `spw` в раунде 2.
- **Лидерборд**: чем меньше `spw`, тем лучше позиция.
- **Нулевые угадывания**: если `guessedCount = 0`, SPW не определяется — в UI показываем «—», из SPW‑лидербордов игрок исключается до первого угаданного слова.

### 20.15. Дополнительные метрики игровой сессии

#### 20.15.1. Отслеживание пропущенных слов
- **Назначение**: определение самого часто пропускаемого слова в партии
- **Структура данных**: `wordTracking.passedWords[word] = count`
- **Логика**: при каждом нажатии кнопки "Пропуск" увеличивается счетчик для текущего слова
- **Инициализация**: структуры данных создаются при запуске сессии
- **Расчет факта**: при завершении сессии находится слово с максимальным счетчиком

#### 20.15.2. Отслеживание времени показа слов
- **Назначение**: определение самого сложного слова (на которое потрачено больше всего времени)
- **Структура данных**: `wordTracking.wordDisplayTime[word] = totalTimeSeconds`
- **Логика**: 
  - Время показа = время от момента выдачи слова до момента угадывания/пропуска
  - При показе слова фиксируется время начала показа в `_wordShownAt`
  - При угадывании/пропуске слова к суммарному времени добавляется время показа в секундах
  - Для пропущенных слов (0 секунд) добавляется 0
  - При истечении времени хода добавляется время на таймере в момент выдачи слова
  - Паузы не влияют на расчет времени (таймер хода на фронте не учитывает паузы)
- **Инициализация**: структуры данных создаются при запуске сессии
- **Расчет факта**: при завершении сессии находится слово с максимальным суммарным временем

#### 20.15.3. Продолжительность раундов и партии
- **Назначение**: отслеживание времени игры для аналитики
- **Структура данных**: 
  - `duration.roundDurations[round] = durationSeconds` - продолжительность каждого раунда в секундах
  - `duration.totalGameDuration = totalSeconds` - общая продолжительность партии в секундах
- **Логика**: 
  - Используется только активное время (исключая паузы)
  - Основано на суммировании времени всех ходов в раунде
  - Не включает время переходов между раундами
- **Инициализация**: структуры данных создаются при запуске сессии
- **Сбор данных**: 
  - При завершении раунда фиксируется его продолжительность (сумма времени всех ходов)
  - При завершении партии рассчитывается общая продолжительность (сумма всех раундов)

### 20.16. Отображение статистики в UI
- **Личные результаты в конце игры (сессионные)**: показываем только количество очков игрока за текущую игровую сессию.
- **Глобальная статистика игрока (all‑time)**: детальные метрики — игры, победы/winrate (с учётом ничьих), рекорды по раундам, медианные SPW по каждому раунду, лучшая серия побед и текущая серия побед. Источник данных на локальном этапе — файловое хранилище через локальные API; после миграции — БД.
- **Дополнительные факты сессии**: самые часто пропускаемые и сложные слова, продолжительность раундов и партии (планируется отдельный экран в будущих задачах).

### 20.17. Тестирование дополнительных метрик
- **Unit-тесты**: подробные тесты для всех новых методов StatsService
- **Интеграционные тесты**: проверка корректности сбора метрик в реальных игровых сценариях
- **Граничные случаи**: тесты для обработки истечения времени, пауз, пустых структур данных
- **Валидация данных**: тесты для проверки корректности форматов времени и счетчиков
- **Производительность**: тесты для проверки отсутствия утечек памяти при длительных сессиях

### 20.18. Интеграция MongoDB (локальная база данных)
  Строка подключения для программ:

#### 20.18.1. Цели интеграции MongoDB
- **Основная цель**: Централизованное хранение статистики пользователей и словарей игры
- **Архитектура**: Локальная игра с минимальным взаимодействием с сервером (только загрузка данных в начале и сохранение результатов в конце)
- **Данные для хранения**: Словари игры и статистика пользователей (финальные результаты, без промежуточных состояний)
- **Аналитика**: Статистика по каждому отдельному пользователю и общие рейтинги

#### 20.18.2. Упрощение архитектуры
- **Удаление избыточности**: Убрать постоянное сохранение промежуточного состояния игры в БД
- **Финальное сохранение**: Сохранять только результаты игры и статистику в конце сессии
- **WebSocket**: Использовать только для загрузки информации в начале и передачи результатов в конце партии
- **Статистика в реальном времени**: Не требуется для локальной игры

#### 20.18.3. Схема MongoDB
```javascript
// Коллекция: players
{
  _id: ObjectId,
  playerKey: String, // "tg:123456" или "name:sha1hash"
  telegramUserId: String, // опционально
  displayName: String,
  displayNameHistory: [String],
  createdAt: Date,
  lastPlayedAt: Date
}

// Коллекция: player_stats
{
  _id: ObjectId,
  playerKey: String, // ссылка на players.playerKey
  totals: {
    gamesPlayed: Number,
    wins: Number,
    wordsGuessed: Number,
    wordsPassed: Number,
    totalScore: Number,
    maxPointsPerGame: Number
  },
  perRoundSpwSamples: {
    r0: [Number], // массив SPW значений для медианы
    r1: [Number],
    r2: [Number]
  },
  bestFirstRoundSpw: Number,
  bestSecondRoundSpw: Number,
  bestThirdRoundSpw: Number,
  bestTurnByRound: {
    r0: Number,
    r1: Number,
    r2: Number
  },
  maxPassedPerGame: Number,
  bestWinStreak: Number,
  currentWinStreak: Number,
  medianSpwByRound: {
    r0: Number,
    r1: Number,
    r2: Number
  },
  updatedAt: Date
}

// Коллекция: games
{
  _id: ObjectId,
  gameId: String, // уникальный ID игры
  startedAt: Date,
  endedAt: Date,
  players: [{
    playerKey: String,
    teamId: String,
    totals: {
      wordsGuessed: Number,
      wordsPassed: Number,
      totalScore: Number,
      spwByRound: {r0: Number, r1: Number, r2: Number},
      bestTurnByRound: {r0: Number, r1: Number, r2: Number}
    }
  }],
  teams: [{
    teamId: String,
    name: String,
    finalScore: Number
  }],
  winners: [String], // массив teamId победителей
  facts: {
    mostPassedWord: {word: String, count: Number},
    hardestWord: {word: String, totalTimeSeconds: Number}
  },
  duration: {
    roundDurations: {r0: Number, r1: Number, r2: Number},
    totalGameDuration: Number
  }
}

// Коллекция: words
{
  _id: ObjectId,
  word: String, // в верхнем регистре
  category: String,
  level: String, // "обычный" или "повышенный"
  createdAt: Date
}

// Коллекция: leaderboards (кэш)
{
  _id: ObjectId,
  metric: String, // "spw_all", "best_streak", etc.
  data: [{
    playerKey: String,
    displayName: String,
    value: Number,
    rank: Number
  }],
  updatedAt: Date
}
```

#### 20.18.4. Индексы MongoDB
```javascript
// Индексы для players
db.players.createIndex({ "playerKey": 1 }, { unique: true })
db.players.createIndex({ "telegramUserId": 1 }, { unique: true, sparse: true })
db.players.createIndex({ "lastPlayedAt": -1 })

// Индексы для player_stats
db.player_stats.createIndex({ "playerKey": 1 }, { unique: true })
db.player_stats.createIndex({ "totals.gamesPlayed": -1 })
db.player_stats.createIndex({ "bestWinStreak": -1 })
db.player_stats.createIndex({ "medianSpwByRound.r0": 1 })
db.player_stats.createIndex({ "medianSpwByRound.r1": 1 })
db.player_stats.createIndex({ "medianSpwByRound.r2": 1 })

// Индексы для games
db.games.createIndex({ "gameId": 1 }, { unique: true })
db.games.createIndex({ "startedAt": -1 })
db.games.createIndex({ "endedAt": -1 })
db.games.createIndex({ "players.playerKey": 1 })

// Индексы для words
db.words.createIndex({ "word": 1 }, { unique: true })
db.words.createIndex({ "category": 1 })
db.words.createIndex({ "level": 1 })
db.words.createIndex({ "category": 1, "level": 1 })

// Индексы для leaderboards
db.leaderboards.createIndex({ "metric": 1 }, { unique: true })
db.leaderboards.createIndex({ "updatedAt": -1 })
```

#### 20.18.5. План миграции
1. **Установка MongoDB** и зависимостей (mongodb driver)
2. **Создание MongoDB репозиториев** (MongoStatsRepository, MongoWordRepository)
3. **Конфигурация** через переменные окружения для переключения между файловой системой и MongoDB
4. **Скрипт миграции данных** из существующих файлов в MongoDB
5. **Обновление тестов** для работы с MongoDB
6. **Документация** по настройке и использованию

#### 20.18.6. Конфигурация
```javascript
// .env файл
// Пример для Docker с аутентификацией (admin / MyStrongPass2025!)
MONGODB_URI=mongodb://admin:MyStrongPass2025!@localhost:27017/?authSource=admin
MONGODB_DATABASE=hat_game
USE_MONGODB=true
STATS_STORAGE_TYPE=mongodb // или "filesystem"
WORDS_STORAGE_TYPE=mongodb // или "filesystem"
```

#### 20.18.7. Docker заметки и совместимость версий
- Если в volume уже есть данные и контейнер падает с ошибкой `featureCompatibilityVersion ... expected '6.0'|'6.3'|'7.0'` — это означает, что данные были созданы в MongoDB 8.0. Решения:
  - Либо используйте образ `mongo:8.0`,
  - Либо очистите volume (данные будут удалены) и поднимите `mongo:7.0`.
- Рекомендуемый запуск:
  - `docker volume create mongo_data`
  - `docker run -d --name mongo -p 27017:27017 -e MONGO_INITDB_ROOT_USERNAME=admin -e MONGO_INITDB_ROOT_PASSWORD='MyStrongPass2025!' -e MONGO_INITDB_DATABASE=hat_game -v mongo_data:/data/db mongo:8.0`

#### 20.18.8. Процедура миграции
1. `npm run init:mongodb` — создаёт индексы
2. `npm run migrate:mongodb` — переносит словарь, статистику игроков, лидерборды и JSONL‑события в MongoDB
3. `npm start` — старт сервера; в логах видно, что используются `MongoDB` репозитории

### 20.19. Политика обновления глобальной статистики
- Глобальная персональная статистика (включая `gamesPlayed`, `wins`, `maxPointsPerGame`, медианы SPW, серии и рекорды) обновляется строго один раз — при корректном завершении партии, когда определён победитель (или победители при ничьей).
- В партиях без победителя (или незавершённых) глобальные метрики не изменяются.

### 20.20. Лидерборды (полный перечень на MVP)
- `spw_all` — медианная SPW суммарно (меньше — лучше)
- `spw_r1`, `spw_r2`, `spw_r3` — медианные SPW по раундам
- `best_round_spw_r1`, `best_round_spw_r2`, `best_round_spw_r3` — лучшие (минимальные) SPW по раундам
- `best_streak` — лучшая серия побед
- `max_points_per_game` — максимум баллов за партию
- `max_passed_per_game` — максимум пропущенных за партию
- `best_turn_r1`, `best_turn_r2`, `best_turn_r3` — лучший ход (макс. очков за один ход) по каждому раунду
- **Абстракции**: `StatsRepository`/`IdentityRepository` с файловой реализацией сейчас (`File*Repository`) и `Db*Repository` потом.
- **БД (рекомендация)**: PostgreSQL.
- **Схема (набросок)**:
  - `players(player_id pk, telegram_user_id unique null, display_name, created_at)`
  - `player_stats(player_id fk, totals jsonb, categories jsonb, last_played_at, primary key (player_id))`
  - `games(game_id pk, started_at, ended_at, meta jsonb)`
  - `game_events(game_id fk, seq, ts, type, payload jsonb, primary key (game_id, seq))`
- **Миграция данных**: импорт файлов `public/stats/players/*.json` в `players`/`player_stats`; консолидация `name:<sha1>` → `tg:<id>` на уровне ETL.
- **Бот**: сервер принимает webhook от Telegram, управляет сессиями и авторизацией, фронт подключается к комнате/игре через сервер.